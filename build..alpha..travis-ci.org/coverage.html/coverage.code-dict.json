{"/home/travis/build/npmtest/node-npmtest-bookshelf/test.js":"/* istanbul instrument in package npmtest_bookshelf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bookshelf/lib.npmtest_bookshelf.js":"/* istanbul instrument in package npmtest_bookshelf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_bookshelf = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_bookshelf = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-bookshelf/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-bookshelf && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_bookshelf */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_bookshelf\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_bookshelf.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_bookshelf.rollup.js'] =\n            local.assetsDict['/assets.npmtest_bookshelf.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_bookshelf.__dirname +\n                    '/lib.npmtest_bookshelf.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/bookshelf.js":"/**\n * (c) 2013-present Tim Griesser\n * Bookshelf may be freely distributed under the MIT license.\n * For all details and documentation:\n * http://bookshelfjs.org\n *\n */\nmodule.exports = require('./lib/bookshelf').default;\n","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/bookshelf.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nvar _events = require('./base/events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _model = require('./model');\n\nvar _model2 = _interopRequireDefault(_model);\n\nvar _collection = require('./collection');\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _relation2 = require('./relation');\n\nvar _relation3 = _interopRequireDefault(_relation2);\n\nvar _errors = require('./errors');\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @class Bookshelf\n * @classdesc\n *\n * The Bookshelf library is initialized by passing an initialized Knex client\n * instance. The knex documentation provides a number of examples for different\n * databases.\n *\n * @constructor\n * @param {Knex} knex Knex instance.\n */\n\n\n// All core modules required for the bookshelf instance.\nfunction Bookshelf(knex) {\n  var bookshelf = {\n    VERSION: require('../package.json').version\n  };\n\n  var Model = bookshelf.Model = _model2.default.extend({\n\n    _builder: builderFn,\n\n    // The `Model` constructor is referenced as a property on the `Bookshelf`\n    // instance, mixing in the correct `builder` method, as well as the\n    // `relation` method, passing in the correct `Model` & `Collection`\n    // constructors for later reference.\n    _relation: function _relation(type, Target, options) {\n      if (type !== 'morphTo' && !(0, _lodash.isFunction)(Target)) {\n        throw new Error('A valid target model must be defined for the ' + (0, _lodash.result)(this, 'tableName') + ' ' + type + ' relation');\n      }\n      return new Relation(type, Target, options);\n    }\n  }, {\n\n    /**\n     * @method Model.forge\n     * @belongsTo Model\n     * @description\n     *\n     * A simple helper function to instantiate a new Model without needing `new`.\n     *\n     * @param {Object=} attributes Initial values for this model's attributes.\n     * @param {Object=}  options               Hash of options.\n     * @param {string=}  options.tableName     Initial value for {@linkcode Model#tableName tableName}.\n     * @param {boolean=} [options.hasTimestamps=false]\n     *\n     *   Initial value for {@linkcode Model#hasTimestamps hasTimestamps}.\n     *\n     * @param {boolean} [options.parse=false]\n     *\n     *   Convert attributes by {@linkcode Model#parse parse} before being\n     *   {@linkcode Model#set set} on the `model`.\n     */\n    forge: forge,\n\n    /**\n     * @method Model.collection\n     * @belongsTo Model\n     * @description\n     *\n     * A simple static helper to instantiate a new {@link Collection}, setting\n     * the current `model` as the collection's target.\n     *\n     * @example\n     *\n     * Customer.collection().fetch().then(function(collection) {\n     *   // ...\n     * });\n     *\n     * @param {(Model[])=} models\n     * @param {Object=} options\n     * @returns {Collection}\n     */\n    collection: function collection(models, options) {\n      return new bookshelf.Collection(models || [], (0, _lodash.extend)({}, options, { model: this }));\n    },\n\n\n    /**\n     * @method Model.count\n     * @belongsTo Model\n     * @since 0.8.2\n     * @description\n     *\n     * Gets the number of matching records in the database, respecting any\n     * previous calls to {@link Model#query query}. If a `column` is provided,\n     * records with a null value in that column will be excluded from the count.\n     *\n     * @param {string} [column='*']\n     *   Specify a column to count - rows with null values in this column will be excluded.\n     * @param {Object=} options\n     *   Hash of options.\n     * @returns {Promise<Number>}\n     *   A promise resolving to the number of matching rows.\n     */\n    count: function count(column, options) {\n      return this.forge().count(column, options);\n    },\n\n\n    /**\n     * @method Model.fetchAll\n     * @belongsTo Model\n     * @description\n     *\n     * Simple helper function for retrieving all instances of the given model.\n     *\n     * @see Model#fetchAll\n     * @returns {Promise<Collection>}\n     */\n    fetchAll: function fetchAll(options) {\n      return this.forge().fetchAll(options);\n    }\n  });\n\n  var Collection = bookshelf.Collection = _collection2.default.extend({\n\n    _builder: builderFn\n\n  }, {\n\n    /**\n     * @method Collection.forge\n     * @belongsTo Collection\n     * @description\n     *\n     * A simple helper function to instantiate a new Collection without needing\n     * new.\n     *\n     * @param {(Object[]|Model[])=} [models]\n     *   Set of models (or attribute hashes) with which to initialize the\n     *   collection.\n     * @param {Object} options Hash of options.\n     *\n     * @example\n     *\n     * var Promise = require('bluebird');\n     * var Accounts = bookshelf.Collection.extend({\n     *   model: Account\n     * });\n     *\n     * var accounts = Accounts.forge([\n     *   {name: 'Person1'},\n     *   {name: 'Person2'}\n     * ]);\n     *\n     * Promise.all(accounts.invoke('save')).then(function() {\n     *   // collection models should now be saved...\n     * });\n     */\n    forge: forge\n\n  });\n\n  // The collection also references the correct `Model`, specified above, for\n  // creating new `Model` instances in the collection.\n  Collection.prototype.model = Model;\n  Model.prototype.Collection = Collection;\n\n  var Relation = _relation3.default.extend({\n    Model: Model, Collection: Collection\n  });\n\n  // A `Bookshelf` instance may be used as a top-level pub-sub bus, as it mixes\n  // in the `Events` object. It also contains the version number, and a\n  // `Transaction` method referencing the correct version of `knex` passed into\n  // the object.\n  (0, _lodash.extend)(bookshelf, _events2.default, _errors2.default, {\n\n    /**\n     * @method Bookshelf#transaction\n     * @memberOf Bookshelf\n     * @description\n     *\n     * An alias to `{@link http://knexjs.org/#Transactions\n     * Knex#transaction}`, the `transaction` object must be passed along in the\n     * options of any relevant Bookshelf calls, to ensure all queries are on the\n     * same connection. The entire transaction block is a promise that will\n     * resolve when the transaction is committed, or fail if the transaction is\n     * rolled back.\n     *\n     *     var Promise = require('bluebird');\n     *\n     *     Bookshelf.transaction(function(t) {\n     *       return new Library({name: 'Old Books'})\n     *         .save(null, {transacting: t})\n     *         .tap(function(model) {\n     *           return Promise.map([\n     *             {title: 'Canterbury Tales'},\n     *             {title: 'Moby Dick'},\n     *             {title: 'Hamlet'}\n     *           ], function(info) {\n     *             // Some validation could take place here.\n     *             return new Book(info).save({'shelf_id': model.id}, {transacting: t});\n     *           });\n     *         });\n     *     }).then(function(library) {\n     *       console.log(library.related('books').pluck('title'));\n     *     }).catch(function(err) {\n     *       console.error(err);\n     *     });\n     *\n     * @param {Bookshelf~transactionCallback} transactionCallback\n     *    Callback containing transaction logic. The callback should return a\n     *    promise.\n     *\n     * @returns {Promise<mixed>}\n     *    A promise resolving to the value returned from {@link\n     *    Bookshelf~transactionCallback transactionCallback}.\n     */\n    transaction: function transaction() {\n      return this.knex.transaction.apply(this, arguments);\n    },\n\n\n    /**\n     * @callback Bookshelf~transactionCallback\n     * @description\n     *\n     * A transaction block to be provided to {@link Bookshelf#transaction}.\n     *\n     * @see {@link http://knexjs.org/#Transactions Knex#transaction}\n     * @see Bookshelf#transaction\n     *\n     * @param {Transaction} transaction\n     * @returns {Promise<mixed>}\n     */\n\n    // Provides a nice, tested, standardized way of adding plugins to a\n    // `Bookshelf` instance, injecting the current instance into the plugin,\n    // which should be a module.exports.\n    plugin: function plugin(_plugin, options) {\n      var _this = this;\n\n      if ((0, _lodash.isString)(_plugin)) {\n        try {\n          require('./plugins/' + _plugin)(this, options);\n        } catch (e) {\n          if (e.code !== 'MODULE_NOT_FOUND') {\n            throw e;\n          }\n          if (!process.browser) {\n            require(_plugin)(this, options);\n          }\n        }\n      } else if ((0, _lodash.isArray)(_plugin)) {\n        (0, _lodash.each)(_plugin, function (p) {\n          _this.plugin(p, options);\n        });\n      } else {\n        _plugin(this, options);\n      }\n      return this;\n    }\n  });\n\n  /**\n   * @member Bookshelf#knex\n   * @memberOf Bookshelf\n   * @type {Knex}\n   * @description\n   * A reference to the {@link http://knexjs.org Knex.js} instance being used by Bookshelf.\n   */\n  bookshelf.knex = knex;\n\n  // The `forge` function properly instantiates a new Model or Collection\n  // without needing the `new` operator... to make object creation cleaner\n  // and more chainable.\n  function forge() {\n    return new (Function.prototype.bind.apply(this, [null].concat(Array.prototype.slice.call(arguments))))();\n  }\n\n  function builderFn(tableNameOrBuilder) {\n    var _this2 = this;\n\n    var builder = null;\n\n    if ((0, _lodash.isString)(tableNameOrBuilder)) {\n      builder = bookshelf.knex(tableNameOrBuilder);\n    } else if (tableNameOrBuilder == null) {\n      builder = bookshelf.knex.queryBuilder();\n    } else {\n      // Assuming here that `tableNameOrBuilder` is a QueryBuilder instance. Not\n      // aware of a way to check that this is the case (ie. using\n      // `Knex.isQueryBuilder` or equivalent).\n      builder = tableNameOrBuilder;\n    }\n\n    return builder.on('query', function (data) {\n      return _this2.trigger('query', data);\n    });\n  }\n\n  // Attach `where`, `query`, and `fetchAll` as static methods.\n  ['where', 'query'].forEach(function (method) {\n    Model[method] = Collection[method] = function () {\n      var model = this.forge();\n      return model[method].apply(model, arguments);\n    };\n  });\n\n  return bookshelf;\n}\n\n// Constructor for a new `Bookshelf` object, it accepts an active `knex`\n// instance and initializes the appropriate `Model` and `Collection`\n// constructors for use in the current instance.\n\n\n// We've supplemented `Events` with a `triggerThen` method to allow for\n// asynchronous event handling via promises. We also mix this into the\n// prototypes of the main objects in the library.\nBookshelf.initialize = function (knex) {\n  _helpers2.default.warn(\"Bookshelf.initialize is deprecated, pass knex directly: require('bookshelf')(knex)\");\n  return new Bookshelf(knex);\n};\n\n// Finally, export `Bookshelf` to the world.\nexports.default = Bookshelf;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/helpers.js":"'use strict';\n\n/* eslint no-console: 0 */\n\n// Helpers\n// ---------------\nvar _ = require('lodash');\nvar chalk = require('chalk');\n\nvar helpers = {\n\n  // Sets the constraints necessary during a `model.save` call.\n  saveConstraints: function saveConstraints(model, relatedData) {\n    var data = {};\n    if (relatedData && !relatedData.isThrough() && relatedData.type !== 'belongsToMany' && relatedData.type !== 'belongsTo') {\n      data[relatedData.key('foreignKey')] = relatedData.parentFk || model.get(relatedData.key('foreignKey'));\n      if (relatedData.isMorph()) data[relatedData.key('morphKey')] = relatedData.key('morphValue');\n    }\n    return model.set(model.parse(data));\n  },\n\n  // Finds the specific `morphTo` table we should be working with, or throws\n  // an error if none is matched.\n  morphCandidate: function morphCandidate(candidates, foreignTable) {\n    var Target = _.find(candidates, function (Candidate) {\n      return _.result(Candidate.prototype, 'tableName') === foreignTable;\n    });\n    if (!Target) {\n      throw new Error('The target polymorphic model was not found');\n    }\n    return Target;\n  },\n\n  // If there are no arguments, return the current object's\n  // query builder (or create and return a new one). If there are arguments,\n  // call the query builder with the first argument, applying the rest.\n  // If the first argument is an object, assume the keys are query builder\n  // methods, and the values are the arguments for the query.\n  query: function query(obj, args) {\n\n    // Ensure the object has a query builder.\n    if (!obj._knex) {\n      var tableName = _.result(obj, 'tableName');\n      obj._knex = obj._builder(tableName);\n    }\n\n    // If there are no arguments, return the query builder.\n    if (args.length === 0) return obj._knex;\n\n    var method = args[0];\n\n    if (_.isFunction(method)) {\n\n      // `method` is a query builder callback. Call it on the query builder\n      // object.\n      method.call(obj._knex, obj._knex);\n    } else if (_.isObject(method)) {\n\n      // `method` is an object. Use keys as methods and values as arguments to\n      // the query builder.\n      for (var key in method) {\n        var target = _.isArray(method[key]) ? method[key] : [method[key]];\n        obj._knex[key].apply(obj._knex, target);\n      }\n    } else {\n\n      // Otherwise assume that the `method` is string name of a query builder\n      // method, and use the remaining args as arguments to that method.\n      obj._knex[method].apply(obj._knex, args.slice(1));\n    }\n    return obj;\n  },\n\n  error: function error(msg) {\n    console.log(chalk.red(msg));\n  },\n\n  warn: function warn(msg) {\n    console.log(chalk.yellow(msg));\n  },\n\n  deprecate: function deprecate(a, b) {\n    helpers.warn(a + ' has been deprecated, please use ' + b + ' instead');\n  },\n\n  orderBy: function orderBy(obj, sort, order) {\n\n    var tableName = void 0;\n    var idAttribute = void 0;\n\n    if (obj.model) {\n      tableName = obj.model.prototype.tableName;\n      idAttribute = obj.model.prototype.idAttribute ? obj.model.prototype.idAttribute : 'id';\n    } else {\n      tableName = obj.constructor.prototype.tableName;\n      idAttribute = obj.constructor.prototype.idAttribute ? obj.constructor.prototype.idAttribute : 'id';\n    }\n\n    var _sort = void 0;\n\n    if (sort && sort.indexOf('-') === 0) {\n      _sort = sort.slice(1);\n    } else if (sort) {\n      _sort = sort;\n    } else {\n      _sort = idAttribute;\n    }\n\n    var _order = order || (sort && sort.indexOf('-') === 0 ? 'DESC' : 'ASC');\n\n    if (_sort.indexOf('.') === -1) {\n      _sort = tableName + '.' + _sort;\n    }\n\n    return obj.query(function (qb) {\n      qb.orderBy(_sort, _order);\n    });\n  }\n};\n\nmodule.exports = helpers;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/base/events.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _get2 = require('babel-runtime/helpers/get');\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _promise = require('./promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _events = require('events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _lodash = require('lodash');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar EventEmitter = _events2.default.EventEmitter; // Events\n// ---------------\n\nvar eventNames = function eventNames(text) {\n  return text.split(/\\s+/);\n};\n\n/**\n * @class Events\n * @description\n * Base Event class inherited by {@link Model} and {@link Collection}. It's not\n * meant to be used directly, and is only displayed here for completeness.\n */\n\nvar Events = function (_EventEmitter) {\n  (0, _inherits3.default)(Events, _EventEmitter);\n\n  function Events() {\n    (0, _classCallCheck3.default)(this, Events);\n    return (0, _possibleConstructorReturn3.default)(this, (Events.__proto__ || Object.getPrototypeOf(Events)).apply(this, arguments));\n  }\n\n  (0, _createClass3.default)(Events, [{\n    key: 'on',\n\n\n    /**\n     * @method Events#on\n     * @description\n     * Register an event listener. The callback will be invoked whenever the event\n     * is fired. The event string may also be a space-delimited list of several\n     * event names.\n     *\n     * @param {string} nameOrNames\n     *   The name of the event or space separated list of events to register a\n     *   callback for.\n     * @param {function} callback\n     *   That callback to invoke whenever the event is fired.\n     */\n    value: function on(nameOrNames, handler) {\n      var _this2 = this;\n\n      (0, _lodash.each)(eventNames(nameOrNames), function (name) {\n        (0, _get3.default)(Events.prototype.__proto__ || Object.getPrototypeOf(Events.prototype), 'on', _this2).call(_this2, name, handler);\n      });\n      return this;\n    }\n\n    /**\n     * @method Events#off\n     * @description\n     * Remove a previously-bound callback event listener from an object. If no\n     * event name is specified, callbacks for all events will be removed.\n     *\n     * @param {string} nameOrNames\n     *   The name of the event or space separated list of events to stop listening\n     *   to.\n     */\n\n  }, {\n    key: 'off',\n    value: function off(nameOrNames) {\n      var _this3 = this;\n\n      if (nameOrNames == null) {\n        return this.removeAllListeners();\n      }\n\n      (0, _lodash.each)(eventNames(nameOrNames), function (name) {\n        return _this3.removeAllListeners(name);\n      });\n      return this;\n    }\n\n    /**\n     * @method Events#trigger\n     * @description\n     * Trigger callbacks for the given event, or space-delimited list of events.\n     * Subsequent arguments to `trigger` will be passed along to the event\n     * callback.\n     *\n     * @param {string} nameOrNames\n     *   The name of the event to trigger. Also accepts a space separated list of\n     *   event names.\n     * @param {...mixed} [args]\n     *   Extra arguments to pass to the event listener callback function.\n     */\n\n  }, {\n    key: 'trigger',\n    value: function trigger(nameOrNames) {\n      var _this4 = this;\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      (0, _lodash.each)(eventNames(nameOrNames), function (name) {\n        _this4.emit.apply(_this4, [name].concat(args));\n      });\n      return this;\n    }\n\n    /**\n     * @method Events#triggerThen\n     * @description\n     * A promise version of {@link Events#trigger}, returning a promise which\n     * resolves with all return values from triggered event handlers. If any of the\n     * event handlers throw an `Error` or return a rejected promise, the promise\n     * will be rejected. Used internally on the {@link Model#creating \"creating\"},\n     * {@link Model#updating \"updating\"}, {@link Model#saving \"saving\"}, and {@link\n     * Model@destroying \"destroying\"} events, and can be helpful when needing async\n     * event handlers (for validations, etc).\n     *\n     * @param {string} name\n     *   The event name, or a whitespace-separated list of event names, to be\n     *   triggered.\n     * @param {...mixed} [args]\n     *   Arguments to be passed to any registered event handlers.\n     * @returns Promise<mixed[]>\n     *   A promise resolving the the resolved return values of any triggered handlers.\n     */\n\n  }, {\n    key: 'triggerThen',\n    value: function triggerThen(nameOrNames) {\n      var _this5 = this;\n\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var names = eventNames(nameOrNames);\n      var listeners = (0, _lodash.flatMap)(names, function (name) {\n        return _this5.listeners(name);\n      });\n      return _promise2.default.map(listeners, function (listener) {\n        return listener.apply(_this5, args);\n      });\n    }\n\n    /**\n     * @method Events#once\n     * @description\n     * Just like {@link Events#on}, but causes the bound callback to fire only\n     * once before being removed. Handy for saying \"the next time that X happens,\n     * do this\". When multiple events are passed in using the space separated\n     * syntax, the event will fire once for every event you passed in, not once\n     * for a combination of all events.\n     *\n     * @param {string} nameOrNames\n     *   The name of the event or space separated list of events to register a\n     *   callback for.\n     * @param {function} callback\n     *   That callback to invoke only once when the event is fired.\n     */\n\n  }, {\n    key: 'once',\n    value: function once(name, callback) {\n      var _this6 = this;\n\n      var wrapped = (0, _lodash.once)(function () {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        _this6.off(name, wrapped);\n        return callback.apply(_this6, args);\n      });\n      wrapped._callback = callback;\n      return this.on(name, wrapped);\n    }\n  }]);\n  return Events;\n}(EventEmitter);\n\nexports.default = Events;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/base/promise.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _bluebird = require('bluebird');\n\nvar _bluebird2 = _interopRequireDefault(_bluebird);\n\nvar _helpers = require('../helpers');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_bluebird2.default.prototype.yield = function () {\n  (0, _helpers.deprecate)('.yield', '.return');\n  return this.return.apply(this, arguments);\n};\n_bluebird2.default.prototype.ensure = function () {\n  (0, _helpers.deprecate)('.ensure', '.finally');\n  return this.finally.apply(this, arguments);\n};\n_bluebird2.default.prototype.otherwise = function () {\n  (0, _helpers.deprecate)('.otherwise', '.catch');\n  return this.catch.apply(this, arguments);\n};\n_bluebird2.default.prototype.exec = function () {\n  (0, _helpers.deprecate)('bookshelf.exec', 'bookshelf.asCallback');\n  return this.nodeify.apply(this, arguments);\n};\n\nexports.default = _bluebird2.default;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/model.js":"'use strict';\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _createError = require('create-error');\n\nvar _createError2 = _interopRequireDefault(_createError);\n\nvar _sync = require('./sync');\n\nvar _sync2 = _interopRequireDefault(_sync);\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nvar _eager = require('./eager');\n\nvar _eager2 = _interopRequireDefault(_eager);\n\nvar _errors = require('./errors');\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _model = require('./base/model');\n\nvar _model2 = _interopRequireDefault(_model);\n\nvar _promise = require('./base/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @class Model\n * @extends ModelBase\n * @inheritdoc\n * @classdesc\n *\n * Models are simple objects representing individual database rows, specifying\n * the tableName and any relations to other models. They can be extended with\n * any domain-specific methods, which can handle components such as validations,\n * computed properties, and access control.\n *\n * @constructor\n * @description\n *\n * When creating an instance of a model, you can pass in the initial values of\n * the attributes, which will be {@link Model#set set} on the\n * model. If you define an {@link initialize} function, it will be invoked\n * when the model is created.\n *\n *     new Book({\n *       title: \"One Thousand and One Nights\",\n *       author: \"Scheherazade\"\n *     });\n *\n * In rare cases, if you're looking to get fancy, you may want to override\n * {@link Model#constructor constructor}, which allows you to replace the\n * actual constructor function for your model.\n *\n *     let Book = bookshelf.Model.extend({\n *       tableName: 'documents',\n *       constructor: function() {\n *         bookshelf.Model.apply(this, arguments);\n *         this.on('saving', function(model, attrs, options) {\n *           options.query.where('type', '=', 'book');\n *         });\n *       }\n *     });\n *\n * @param {Object}   attributes            Initial values for this model's attributes.\n * @param {Object=}  options               Hash of options.\n * @param {string=}  options.tableName     Initial value for {@link Model#tableName tableName}.\n * @param {boolean=} [options.hasTimestamps=false]\n *\n *   Initial value for {@link Model#hasTimestamps hasTimestamps}.\n *\n * @param {boolean} [options.parse=false]\n *\n *   Convert attributes by {@link Model#parse parse} before being {@link\n *   Model#set set} on the model.\n *\n */\nvar BookshelfModel = _model2.default.extend({\n\n  /**\n   * The `hasOne` relation specifies that this table has exactly one of another\n   * type of object, specified by a foreign key in the other table.\n   *\n   *     let Record = bookshelf.Model.extend({\n   *       tableName: 'health_records'\n   *     });\n   *\n   *     let Patient = bookshelf.Model.extend({\n   *       tableName: 'patients',\n   *       record: function() {\n   *         return this.hasOne(Record);\n   *       }\n   *     });\n   *\n   *     // select * from `health_records` where `patient_id` = 1;\n   *     new Patient({id: 1}).related('record').fetch().then(function(model) {\n   *       // ...\n   *     });\n   *\n   *     // alternatively, if you don't need the relation loaded on the patient's relations hash:\n   *     new Patient({id: 1}).record().fetch().then(function(model) {\n   *       // ...\n   *     });\n   *\n   * @method Model#hasOne\n   *\n   * @param {Model} Target\n   *\n   *   Constructor of {@link Model} targeted by join.\n   *\n   * @param {string=} foreignKey\n   *\n   *   ForeignKey in the `Target` model. By default, the `foreignKey` is assumed to\n   *   be the singular form of this model's {@link Model#tableName tableName},\n   *   followed by `_id` / `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} foreignKeyTarget\n   *\n   *   Column in the `Target` model's table which `foreignKey` references, if other\n   *   than `Target` model's `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @returns {Model}\n   */\n  hasOne: function hasOne(Target, foreignKey, foreignKeyTarget) {\n    return this._relation('hasOne', Target, { foreignKey: foreignKey, foreignKeyTarget: foreignKeyTarget }).init(this);\n  },\n\n\n  /**\n   * The `hasMany` relation specifies that this model has one or more rows in\n   * another table which match on this model's primary key.\n   *\n   *     let Author = bookshelf.Model.extend({\n   *       tableName: 'authors',\n   *       books: function() {\n   *         return this.hasMany(Book);\n   *       }\n   *     });\n   *\n   *     // select * from `authors` where id = 1\n   *     // select * from `books` where author_id = 1\n   *     Author.where({id: 1}).fetch({withRelated: ['books']}).then(function(author) {\n   *       console.log(JSON.stringify(author.related('books')));\n   *     });\n   *\n   * @method Model#hasMany\n   *\n   * @param {Model} Target\n   *\n   *   Constructor of {@link Model} targeted by join.\n   *\n   * @param {string=} foreignKey\n   *\n   *   ForeignKey in the `Target` model. By default, the foreignKey is assumed to\n   *   be the singular form of this model's tableName, followed by `_id` /\n   *   `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} foreignKeyTarget\n   *\n   *   Column in the `Target` model's table which `foreignKey` references, if other\n   *   than `Target` model's `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @returns {Collection}\n   */\n  hasMany: function hasMany(Target, foreignKey, foreignKeyTarget) {\n    return this._relation('hasMany', Target, { foreignKey: foreignKey, foreignKeyTarget: foreignKeyTarget }).init(this);\n  },\n\n\n  /**\n   * The `belongsTo` relationship is used when a model is a member of\n   * another `Target` model.\n   *\n   * It can be used in a {@linkplain one-to-one} associations as the inverse\n   * of a {@link Model#hasOne hasOne}. It can also used in {@linkplain\n   * one-to-many} associations as the inverse of a {@link Model#hasMany hasMany}\n   * (and is the one side of that association). In both cases, the {@link\n   * Model#belongsTo belongsTo} relationship is used for a model that is a\n   * member of another Target model, referenced by the foreignKey in the current\n   * model.\n   *\n   *     let Book = bookshelf.Model.extend({\n   *       tableName: 'books',\n   *       author: function() {\n   *         return this.belongsTo(Author);\n   *       }\n   *     });\n   *\n   *     // select * from `books` where id = 1\n   *     // select * from `authors` where id = book.author_id\n   *     Book.where({id: 1}).fetch({withRelated: ['author']}).then(function(book) {\n   *       console.log(JSON.stringify(book.related('author')));\n   *     });\n   *\n   * @method Model#belongsTo\n   *\n   * @param {Model} Target\n   *\n   *   Constructor of {@link Model} targeted by join.\n   *\n   * @param {string=} foreignKey\n   *\n   *   ForeignKey in this model. By default, the foreignKey is assumed to\n   *   be the singular form of the `Target` model's tableName, followed by `_id` /\n   *   `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} foreignKeyTarget\n   *\n   *   Column in the `Target` model's table which `foreignKey` references, if other\n   *   than `Target` model's `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @returns {Model}\n   */\n  belongsTo: function belongsTo(Target, foreignKey, foreignKeyTarget) {\n    return this._relation('belongsTo', Target, { foreignKey: foreignKey, foreignKeyTarget: foreignKeyTarget }).init(this);\n  },\n\n\n  /**\n   * Defines a many-to-many relation, where the current model is joined to one\n   * or more of a `Target` model through another table. The default name for\n   * the joining table is the two table names, joined by an underscore, ordered\n   * alphabetically. For example, a `users` table and an `accounts` table would have\n   * a joining table of accounts_users.\n   *\n   *     let Account = bookshelf.Model.extend({\n   *       tableName: 'accounts'\n   *     });\n   *\n   *     let User = bookshelf.Model.extend({\n   *       tableName: 'users',\n   *       allAccounts: function () {\n   *         return this.belongsToMany(Account);\n   *       },\n   *       adminAccounts: function() {\n   *         return this.belongsToMany(Account).query({where: {access: 'admin'}});\n   *       },\n   *       viewAccounts: function() {\n   *         return this.belongsToMany(Account).query({where: {access: 'readonly'}});\n   *       }\n   *     });\n   *\n   *  The default key names in the joining table are the singular versions of the\n   *  model table names, followed by `_id` /\n   *  _{{{@link Model#idAttribute idAttribute}}}. So in the above case, the\n   *  columns in the joining table\n   *  would be `user_id`, `account_id`, and `access`, which is used as an\n   *  example of how dynamic relations can be formed using different contexts.\n   *  To customize the keys used in, or the {@link Model#tableName tableName}\n   *  used for the join table, you may specify them like so:\n   *\n   *      this.belongsToMany(Account, 'users_accounts', 'userid', 'accountid');\n   *\n   * If you wish to create a {@link Model#belongsToMany belongsToMany}\n   * association where the joining table has a primary key, and more information\n   * about the model, you may create a {@link Model#belongsToMany belongsToMany}\n   * {@link Relation#through through} relation:\n   *\n   *     let Doctor = bookshelf.Model.extend({\n   *       patients: function() {\n   *         return this.belongsToMany(Patient).through(Appointment);\n   *       }\n   *     });\n   *\n   *     let Appointment = bookshelf.Model.extend({\n   *       patient: function() {\n   *         return this.belongsTo(Patient);\n   *       },\n   *       doctor: function() {\n   *         return this.belongsTo(Doctor);\n   *       }\n   *     });\n   *\n   *     let Patient = bookshelf.Model.extend({\n   *       doctors: function() {\n   *         return this.belongsToMany(Doctor).through(Appointment);\n   *       }\n   *     });\n   *\n   * Collections returned by a `belongsToMany` relation are decorated with\n   * several pivot helper methods. See {@link Collection#attach attach},\n   * {@link Collection#detach detach}, {@link Collection#updatePivot\n   * updatePivot} and {@link Collection#withPivot withPivot} for more\n   * information.\n   *\n   * @belongsTo Model\n   * @method  Model#belongsToMany\n   * @param {Model} Target\n   *\n   *   Constructor of {@link Model} targeted by join.\n   *\n   * @param {string=} table\n   *\n   *   Name of the joining table. Defaults to the two table names, joined by an\n   *   underscore, ordered alphabetically.\n   *\n   * @param {string=} foreignKey\n   *\n   *   Foreign key in this model. By default, the `foreignKey` is assumed to\n   *   be the singular form of this model's tableName, followed by `_id` /\n   *   `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} otherKey\n   *\n   *   Foreign key in the `Target` model. By default, the `otherKey` is assumed to\n   *   be the singular form of the `Target` model's tableName, followed by `_id` /\n   *   `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} foreignKeyTarget\n   *\n   *   Column in this model's table which `foreignKey` references, if other\n   *   than `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @param {string=} otherKeyTarget\n   *\n   *   Column in the `Target` model's table which `otherKey` references, if other\n   *   than `Target` model's `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @returns {Collection}\n   */\n  belongsToMany: function belongsToMany(Target, joinTableName, foreignKey, otherKey, foreignKeyTarget, otherKeyTarget) {\n    return this._relation('belongsToMany', Target, {\n      joinTableName: joinTableName, foreignKey: foreignKey, otherKey: otherKey, foreignKeyTarget: foreignKeyTarget, otherKeyTarget: otherKeyTarget\n    }).init(this);\n  },\n\n\n  /**\n   * The {@link Model#morphOne morphOne} is used to signify a {@link oneToOne\n   * one-to-one} {@link polymorphicRelation polymorphic relation} with\n   * another `Target` model, where the `name` of the model is used to determine\n   * which database table keys are used. The naming convention requires the\n   * `name` prefix an `_id` and `_type` field in the database. So for the case\n   * below the table names would be `imageable_type` and `imageable_id`. The\n   * `morphValue` may be optionally set to store/retrieve a different value in\n   * the `_type` column than the {@link Model#tableName}.\n   *\n   *     let Site = bookshelf.Model.extend({\n   *       tableName: 'sites',\n   *       photo: function() {\n   *         return this.morphOne(Photo, 'imageable');\n   *       }\n   *     });\n   *\n   * And with custom `columnNames`:\n   *\n   *     let Site = bookshelf.Model.extend({\n   *       tableName: 'sites',\n   *       photo: function() {\n   *         return this.morphOne(Photo, 'imageable', [\"ImageableType\", \"ImageableId\"]);\n   *       }\n   *     });\n   *\n   * Note that both `columnNames` and `morphValue` are optional arguments. How\n   * your argument is treated when only one is specified, depends on the type.\n   * If your argument is an array, it will be assumed to contain custom\n   * `columnNames`. If it's not, it will be assumed to indicate a `morphValue`.\n   *\n   * @method Model#morphOne\n   *\n   * @param {Model}     Target      Constructor of {@link Model} targeted by join.\n   * @param {string=}   name        Prefix for `_id` and `_type` columns.\n   * @param {(string[])=}  columnNames\n   *\n   *   Array containing two column names, the first is the `_type`, the second\n   *   is the `_id`.\n   *\n   * @param {string=} [morphValue=Target#{@link Model#tableName tableName}]\n   *\n   *   The string value associated with this relationship. Stored in the `_type`\n   *   column of the polymorphic table. Defaults to `Target#{@link\n   *   Model#tableName tableName}`.\n   *\n   * @returns {Model} The related model.\n   */\n  morphOne: function morphOne(Target, name, columnNames, morphValue) {\n    return this._morphOneOrMany(Target, name, columnNames, morphValue, 'morphOne');\n  },\n\n\n  /**\n   * {@link Model#morphMany morphMany} is essentially the same as a {@link\n   * Model#morphOne morphOne}, but creating a {@link Collection collection}\n   * rather than a {@link Model model} (similar to a {@link Model#hasOne\n   * hasOne} vs. {@link Model#hasMany hasMany} relation).\n   *\n   * {@link Model#morphMany morphMany} is used to signify a {@link oneToMany\n   * one-to-many} or {@link manyToMany many-to-many} {@link polymorphicRelation\n   * polymorphic relation} with another `Target` model, where the `name` of the\n   * model is used to determine which database table keys are used. The naming\n   * convention requires the `name` prefix an `_id` and `_type` field in the\n   * database. So for the case below the table names would be `imageable_type`\n   * and `imageable_id`. The `morphValue` may be optionally set to\n   * store/retrieve a different value in the `_type` column than the `Target`'s\n   * {@link Model#tableName tableName}.\n   *\n   *     let Post = bookshelf.Model.extend({\n   *       tableName: 'posts',\n   *       photos: function() {\n   *         return this.morphMany(Photo, 'imageable');\n   *       }\n   *     });\n   *\n   * And with custom columnNames:\n   *\n   *     let Post = bookshelf.Model.extend({\n   *       tableName: 'posts',\n   *       photos: function() {\n   *         return this.morphMany(Photo, 'imageable', [\"ImageableType\", \"ImageableId\"]);\n   *       }\n   *     });\n   *\n   * @method Model#morphMany\n   *\n   * @param {Model}     Target      Constructor of {@link Model} targeted by join.\n   * @param {string=}   name        Prefix for `_id` and `_type` columns.\n   * @param {(string[])=}  columnNames\n   *\n   *   Array containing two column names, the first is the `_type`, the second is the `_id`.\n   *\n   * @param {string=} [morphValue=Target#{@link Model#tableName tablename}]\n   *\n   *   The string value associated with this relationship. Stored in the `_type`\n   *   column of the polymorphic table. Defaults to `Target`#{@link Model#tableName\n   *   tablename}.\n   *\n   * @returns {Collection} A collection of related models.\n   */\n  morphMany: function morphMany(Target, name, columnNames, morphValue) {\n    return this._morphOneOrMany(Target, name, columnNames, morphValue, 'morphMany');\n  },\n\n\n  /**\n   * The {@link Model#morphTo morphTo} relation is used to specify the inverse\n   * of the {@link Model#morphOne morphOne} or {@link Model#morphMany\n   * morphMany} relations, where the `targets` must be passed to signify which\n   * {@link Model models} are the potential opposite end of the {@link\n   * polymorphicRelation polymorphic relation}.\n   *\n   *     let Photo = bookshelf.Model.extend({\n   *       tableName: 'photos',\n   *       imageable: function() {\n   *         return this.morphTo('imageable', Site, Post);\n   *       }\n   *     });\n   *\n   * And with custom columnNames:\n   *\n   *     let Photo = bookshelf.Model.extend({\n   *       tableName: 'photos',\n   *       imageable: function() {\n   *         return this.morphTo('imageable', [\"ImageableType\", \"ImageableId\"], Site, Post);\n   *       }\n   *     });\n   *\n   * @method Model#morphTo\n   *\n   * @param {string}      name        Prefix for `_id` and `_type` columns.\n   * @param {(string[])=} columnNames\n   *\n   *   Array containing two column names, the first is the `_type`, the second is the `_id`.\n   *\n   * @param {...Model} Target Constructor of {@link Model} targeted by join.\n   *\n   * @returns {Model}\n   */\n  morphTo: function morphTo(morphName) {\n    if (!_lodash2.default.isString(morphName)) throw new Error('The `morphTo` name must be specified.');\n    var columnNames = void 0,\n        candidates = void 0;\n    if (_lodash2.default.isArray(arguments[1])) {\n      columnNames = arguments[1];\n      candidates = _lodash2.default.drop(arguments, 2);\n    } else {\n      columnNames = null;\n      candidates = _lodash2.default.drop(arguments);\n    }\n    return this._relation('morphTo', null, { morphName: morphName, columnNames: columnNames, candidates: candidates }).init(this);\n  },\n\n\n  /**\n   * Helps to create dynamic relations between {@link Model models} and {@link\n   * Collection collections}, where a {@link Model#hasOne hasOne}, {@link\n   * Model#hasMany hasMany}, {@link Model#belongsTo belongsTo}, or {@link\n   * Model#belongsToMany belongsToMany} relation may run through a `JoinModel`.\n   *\n   * A good example of where this would be useful is if a book {@link\n   * Model#hasMany hasMany} paragraphs through chapters. Consider the following examples:\n   *\n   *\n   *     let Book = bookshelf.Model.extend({\n   *       tableName: 'books',\n   *\n   *       // Find all paragraphs associated with this book, by\n   *       // passing through the \"Chapter\" model.\n   *       paragraphs: function() {\n   *         return this.hasMany(Paragraph).through(Chapter);\n   *       },\n   *\n   *       chapters: function() {\n   *         return this.hasMany(Chapter);\n   *       }\n   *     });\n   *\n   *     let Chapter = bookshelf.Model.extend({\n   *       tableName: 'chapters',\n   *\n   *       paragraphs: function() {\n   *         return this.hasMany(Paragraph);\n   *       }\n   *     });\n   *\n   *     let Paragraph = bookshelf.Model.extend({\n   *       tableName: 'paragraphs',\n   *\n   *       chapter: function() {\n   *         return this.belongsTo(Chapter);\n   *       },\n   *\n   *       // A reverse relation, where we can get the book from the chapter.\n   *       book: function() {\n   *         return this.belongsTo(Book).through(Chapter);\n   *       }\n   *     });\n   *\n   * The \"through\" table creates a pivot model, which it assigns to {@link\n   * Model#pivot model.pivot} after it is created. On {@link Model#toJSON\n   * toJSON}, the pivot model is flattened to values prefixed with\n   * `_pivot_`.\n   *\n   * @method Model#through\n   * @param {Model} Interim Pivot model.\n   * @param {string=} throughForeignKey\n   *\n   *   Foreign key in this model. By default, the `foreignKey` is assumed to\n   *   be the singular form of the `Target` model's tableName, followed by `_id` /\n   *   `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} otherKey\n   *\n   *   Foreign key in the `Interim` model. By default, the `otherKey` is assumed to\n   *   be the singular form of this model's tableName, followed by `_id` /\n   *   `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} throughForeignKeyTarget\n   *\n   *   Column in the `Target` model which `throughForeignKey` references, if other\n   *   than `Target` model's `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @param {string=} otherKeyTarget\n   *\n   *   Column in this model which `otherKey` references, if other\n   *   than `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @returns {Collection}\n   */\n  through: function through(Interim, throughForeignKey, otherKey, throughForeignKeyTarget, otherKeyTarget) {\n    return this.relatedData.through(this, Interim, {\n      throughForeignKey: throughForeignKey, otherKey: otherKey, throughForeignKeyTarget: throughForeignKeyTarget, otherKeyTarget: otherKeyTarget\n    });\n  },\n\n\n  /**\n   * @method Model#refresh\n   * @since 0.8.2\n   * @description\n   *\n   * Update the attributes of a model, fetching it by its primary key. If no\n   * attribute matches its {@link Model#idAttribute idAttribute}, then fetch by\n   * all available fields.\n   *\n   * @param {Object} options\n   *   A hash of options. See {@link Model#fetch} for details.\n   * @returns {Promise<Model>}\n   *   A promise resolving to this model.\n   */\n  refresh: function refresh(options) {\n\n    // If this is new, we use all its attributes. Otherwise we just grab the\n    // primary key.\n    var attributes = this.isNew() ? this.attributes : _lodash2.default.pick(this.attributes, this.idAttribute);\n\n    return this._doFetch(attributes, options);\n  },\n\n\n  /**\n   * Fetches a {@link Model model} from the database, using any {@link\n   * Model#attributes attributes} currently set on the model to form a `select`\n   * query.\n   *\n   * A {@link Model#event:fetching \"fetching\"} event will be fired just before the\n   * record is fetched; a good place to hook into for validation. {@link\n   * Model#event:fetched \"fetched\"} event will be fired when a record is\n   * successfully retrieved.\n   *\n   * If you need to constrain the query\n   * performed by fetch, you can call {@link Model#query query} before calling\n   * {@link Model#fetch fetch}.\n   *\n   *     // select * from `books` where `ISBN-13` = '9780440180296'\n   *     new Book({'ISBN-13': '9780440180296'})\n   *       .fetch()\n   *       .then(function(model) {\n   *         // outputs 'Slaughterhouse Five'\n   *         console.log(model.get('title'));\n   *       });\n   *\n   * _If you'd like to only fetch specific columns, you may specify a `columns`\n   * property in the `options` for the {@link Model#fetch fetch} call, or use\n   * {@link Model#query query}, tapping into the {@link Knex} {@link\n   * Knex#column column} method to specify which columns will be fetched._\n   *\n   * A single property, or an array of properties can be specified as a value for\n   * the `withRelated` property. You can also execute callbacks on relations\n   * queries (eg. for sorting a relation). The results of these relation queries\n   * will be loaded into a {@link Model#relations relations} property on the\n   * model, may be retrieved with the {@link Model#related related} method, and\n   * will be serialized as properties on a {@link Model#toJSON toJSON} call\n   * unless `{shallow: true}` is passed.\n   *\n   *     let Book = bookshelf.Model.extend({\n   *       tableName: 'books',\n   *       editions: function() {\n   *         return this.hasMany(Edition);\n   *       },\n   *       chapters: function() {\n   *         return this.hasMany(Chapter);\n   *       },\n   *       genre: function() {\n   *         return this.belongsTo(Genre);\n   *       }\n   *     })\n   *\n   *     new Book({'ISBN-13': '9780440180296'}).fetch({\n   *       withRelated: [\n   *         'genre', 'editions',\n   *         { chapters: function(query) { query.orderBy('chapter_number'); }}\n   *       ]\n   *     }).then(function(book) {\n   *       console.log(book.related('genre').toJSON());\n   *       console.log(book.related('editions').toJSON());\n   *       console.log(book.toJSON());\n   *     });\n   *\n   * @method Model#fetch\n   *\n   * @param {Object=}  options - Hash of options.\n   * @param {boolean=} [options.require=false]\n   *   Reject the returned response with a {@link Model.NotFoundError\n   *   NotFoundError} if results are empty.\n   * @param {string|string[]} [options.columns='*']\n   *   Specify columns to be retrieved.\n   * @param {Transaction} [options.transacting]\n   *  Optionally run the query in a transaction.\n   * @param {string|Object|mixed[]} [options.withRelated]\n   *  Relations to be retrieved with `Model` instance. Either one or more\n   *  relation names or objects mapping relation names to query callbacks.\n   *\n   * @fires Model#fetching\n   * @fires Model#fetched\n   *\n   * @throws {Model.NotFoundError}\n   *\n   * @returns {Promise<Model|null>}\n   *  A promise resolving to the fetched {@link Model model} or `null` if\n   *  none exists.\n   *\n   */\n  fetch: function fetch(options) {\n\n    // Fetch uses all set attributes.\n    return this._doFetch(this.attributes, options);\n  },\n\n\n  _doFetch: _promise2.default.method(function (attributes, options) {\n    options = options ? _lodash2.default.clone(options) : {};\n\n    // Run the `first` call on the `sync` object to fetch a single model.\n    return this.sync(options).first(attributes).bind(this)\n\n    // Jump the rest of the chain if the response doesn't exist...\n    .tap(function (response) {\n      if (!response || response.length === 0) {\n        throw new this.constructor.NotFoundError('EmptyResponse');\n      }\n    })\n\n    // Now, load all of the data into the model as necessary.\n    .tap(this._handleResponse)\n\n    // If the \"withRelated\" is specified, we also need to eager load all of the\n    // data on the model, as a side-effect, before we ultimately jump into the\n    // next step of the model. Since the `columns` are only relevant to the\n    // current level, ensure those are omitted from the options.\n    .tap(function (response) {\n      if (options.withRelated) {\n        return this._handleEager(response, _lodash2.default.omit(options, 'columns'));\n      }\n    }).tap(function (response) {\n\n      /**\n       * Fired after a `fetch` operation. A promise may be returned from the\n       * event handler for async behaviour.\n       *\n       * @event Model#fetched\n       * @param {Model} model\n       *   The model firing the event.\n       * @param {Object} reponse\n       *   Knex query response.\n       * @param {Object} options\n       *   Options object passed to {@link Model#fetch fetch}.\n       * @returns {Promise}\n       *   If the handler returns a promise, `fetch` will wait for it to\n       *   be resolved.\n       */\n      return this.triggerThen('fetched', this, response, options);\n    }).return(this).catch(this.constructor.NotFoundError, function (err) {\n      if (options.require) {\n        throw err;\n      }\n      return null;\n    });\n  }),\n\n  // Private for now.\n  all: function all() {\n    var collection = this.constructor.collection();\n    collection._knex = this.query().clone();\n    this.resetQuery();\n    if (this.relatedData) collection.relatedData = this.relatedData;\n    return collection;\n  },\n\n\n  /**\n   * @method Model#count\n   * @since 0.8.2\n   * @description\n   *\n   * Gets the number of matching records in the database, respecting any\n   * previous calls to {@link Model#query}.\n   *\n   * @example\n   *\n   * Duck.where('color', 'blue').count('name')\n   *   .then(function(count) { //...\n   *\n   * @param {string} [column='*']\n   *   Specify a column to count - rows with null values in this column will be excluded.\n   * @param {Object=} options\n   *   Hash of options.\n   * @returns {Promise<Number>}\n   *   A promise resolving to the number of matching rows.\n   */\n  count: function count(column, options) {\n    return this.all().count(column, options);\n  },\n\n\n  /**\n   * Fetches a collection of {@link Model models} from the database, using any\n   * query parameters currently set on the model to form a select query. Returns\n   * a promise, which will resolve with the fetched collection. If you wish to\n   * trigger an error if no models are found, pass {require: true} as one of\n   * the options to the `fetchAll` call.\n   *\n   * If you need to constrain the query performed by fetch, you can call the\n   * {@link Model#query query} method before calling fetch.\n   *\n   * @method Model#fetchAll\n   *\n   * @param {Object=}  options - Hash of options.\n   * @param {boolean=} [options.require=false]\n   *\n   *  Rejects the returned promise with an `Collection.EmptyError` if no records are returned.\n   *\n   * @param {Transaction=} options.transacting\n   *\n   *   Optionally run the query in a transaction.\n   *\n   * @fires Model#\"fetching:collection\"\n   * @fires Model#\"fetched:collection\"\n   *\n   * @throws {Collection.EmptyError}\n   *\n   *  Rejects the promise in the event of an empty response if the `require: true` option.\n   *\n   * @returns {Promise<Collection>} A promise resolving to the fetched {@link Collection collection}.\n   *\n   */\n  fetchAll: function fetchAll(options) {\n    var _this = this;\n\n    var collection = this.all();\n    return collection.once('fetching', function (__, columns, opts) {\n      /**\n       * Fired before a {@link Model#fetchAll fetchAll} operation. A promise\n       * may be returned from the event handler for async behaviour.\n       *\n       * @event Model#\"fetching:collection\"\n       * @param {Model}    collection The collection that has been fetched.\n       * @param {string[]} columns    The columns being retrieved by the query.\n       * @param {Object}   options    Options object passed to {@link Model#fetchAll fetchAll}.\n       * @returns {Promise}\n       */\n      return _this.triggerThen('fetching:collection', collection, columns, opts);\n    }).once('fetched', function (__, resp, opts) {\n      /**\n       * Fired after a {@link Model#fetchAll fetchAll} operation. A promise\n       * may be returned from the event handler for async behaviour.\n       *\n       * @event Model#\"fetched:collection\"\n       * @param {Model}  collection The collection that has been fetched.\n       * @param {Object} resp       The Knex query response.\n       * @param {Object} options    Options object passed to {@link Model#fetchAll fetchAll}.\n       * @returns {Promise}\n       */\n      return _this.triggerThen('fetched:collection', collection, resp, opts);\n    }).fetch(options);\n  },\n\n\n  /**\n   * @method Model#load\n   * @description\n   * The load method takes an array of relations to eager load attributes onto a\n   * {@link Model}, in a similar way that the `withRelated` property works on\n   * {@link Model#fetch fetch}. Dot separated attributes may be used to specify deep\n   * eager loading.\n   *\n   * @example\n   * new Posts().fetch().then(function(collection) {\n   *   collection.at(0)\n   *   .load(['author', 'content', 'comments.tags'])\n   *   .then(function(model) {\n   *     JSON.stringify(model);\n   *   });\n   * });\n   *\n   * {\n   *   title: 'post title',\n   *   author: {...},\n   *   content: {...},\n   *   comments: [\n   *     {tags: [...]}, {tags: [...]}\n   *   ]\n   * }\n   *\n   * @param {string|string[]} relations The relation, or relations, to be loaded.\n   * @param {Object=}      options Hash of options.\n   * @param {Transaction=} options.transacting\n   *   Optionally run the query in a transaction.\n   * @returns {Promise<Model>} A promise resolving to this {@link Model model}\n   */\n  load: _promise2.default.method(function (relations, options) {\n    var columns = this.format((0, _extends3.default)({}, this.attributes));\n    var withRelated = _lodash2.default.isArray(relations) ? relations : [relations];\n    return this._handleEager([columns], (0, _extends3.default)({}, options, { shallow: true, withRelated: withRelated })).return(this);\n  }),\n\n  /**\n   * @method Model#save\n   * @description\n   *\n   * `save` is used to perform either an insert or update query using the\n   * model's set {@link Model#attributes attributes}.\n   *\n   * If the model {@link Model#isNew isNew}, any {@link Model#defaults defaults}\n   * will be set and an `insert` query will be performed. Otherwise it will\n   * `update` the record with a corresponding ID. This behaviour can be overriden\n   * with the `method` option.\n   *\n   *     new Post({name: 'New Article'}).save().then(function(model) {\n   *       // ...\n   *     });\n   *\n   * If you only wish to update with the params passed to the save, you may pass\n   * a {patch: true} flag to the database:\n   *\n   *     // update authors set \"bio\" = 'Short user bio' where \"id\" = 1\n   *     new Author({id: 1, first_name: 'User'})\n   *       .save({bio: 'Short user bio'}, {patch: true})\n   *       .then(function(model) {\n   *         // ...\n   *       });\n   *\n   * Several events fired on the model when saving: a {@link Model#creating\n   * \"creating\"}, or {@link Model#updating \"updating\"} event if the model is\n   * being inserted or updated, and a \"saving\" event in either case. To\n   * prevent saving the model (with validation, etc.), throwing an error inside\n   * one of these event listeners will stop saving the model and reject the\n   * promise. A {@link Model#created \"created\"}, or {@link Model#\"updated\"}\n   * event is fired after the model is saved, as well as a {@link Model#saved\n   * \"saved\"} event either way. If you wish to modify the query when the {@link\n   * Model#saving \"saving\"} event is fired, the knex query object should is\n   * available in `options.query`.\n   *\n   *     // Save with no arguments\n   *     Model.forge({id: 5, firstName: \"John\", lastName: \"Smith\"}).save().then(function() { //...\n   *\n   *     // Or add attributes during save\n   *     Model.forge({id: 5}).save({firstName: \"John\", lastName: \"Smith\"}).then(function() { //...\n   *\n   *     // Or, if you prefer, for a single attribute\n   *     Model.forge({id: 5}).save('name', 'John Smith').then(function() { //...\n   *\n   * @param {string=}      key                      Attribute name.\n   * @param {string=}      val                      Attribute value.\n   * @param {Object=}      attrs                    A hash of attributes.\n   * @param {Object=}      options\n   * @param {Transaction=} options.transacting\n   *   Optionally run the query in a transaction.\n   * @param {string=} options.method\n   *   Explicitly select a save method, either `\"update\"` or `\"insert\"`.\n   * @param {string} [options.defaults=false]\n   *   Assign {@link Model#defaults defaults} in an `update` operation.\n   * @param {bool} [options.patch=false]\n   *   Only save attributes supplied in arguments to `save`.\n   * @param {bool} [options.require=true]\n   *   Throw a {@link Model.NoRowsUpdatedError} if no records are affected by save.\n   *\n   * @fires Model#saving\n   * @fires Model#creating\n   * @fires Model#updating\n   * @fires Model#created\n   * @fires Model#updated\n   * @fires Model#saved\n   *\n   * @throws {Model.NoRowsUpdatedError}\n   *\n   * @returns {Promise<Model>} A promise resolving to the saved and updated model.\n   */\n  save: _promise2.default.method(function (key, val, options) {\n    var attrs = void 0;\n\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    if (key == null || (typeof key === 'undefined' ? 'undefined' : (0, _typeof3.default)(key)) === \"object\") {\n      attrs = key || {};\n      options = _lodash2.default.clone(val) || {};\n    } else {\n      (attrs = {})[key] = val;\n      options = options ? _lodash2.default.clone(options) : {};\n    }\n\n    return _promise2.default.bind(this).then(function () {\n      return this.saveMethod(options);\n    }).then(function (method) {\n\n      // Determine whether which kind of save we will do, update or insert.\n      options.method = method;\n\n      // If the object is being created, we merge any defaults here rather than\n      // during object creation.\n      if (method === 'insert' || options.defaults) {\n        var defaults = _lodash2.default.result(this, 'defaults');\n        if (defaults) {\n          attrs = _lodash2.default.defaultsDeep({}, attrs, this.attributes, defaults);\n        }\n      }\n\n      // Set the attributes on the model. Note that we do this before adding\n      // timestamps, as `timestamp` calls `set` internally.\n      this.set(attrs, { silent: true });\n\n      // Now set timestamps if appropriate. Extend `attrs` so that the\n      // timestamps will be provided for a patch operation.\n      if (this.hasTimestamps) {\n        _lodash2.default.extend(attrs, this.timestamp(_lodash2.default.extend(options, { silent: true })));\n      }\n\n      // If there are any save constraints, set them on the model.\n      if (this.relatedData && this.relatedData.type !== 'morphTo') {\n        _helpers2.default.saveConstraints(this, this.relatedData);\n      }\n\n      // Gives access to the `query` object in the `options`, in case we need it\n      // in any event handlers.\n      var sync = this.sync(options);\n      options.query = sync.query;\n\n      /**\n       * Saving event.\n       *\n       * Fired before an `insert` or `update` query. A promise may be\n       * returned from the event handler for async behaviour. Throwing an\n       * exception from the handler will cancel the save.\n       *\n       * @event Model#saving\n       * @param {Model}  model    The model firing the event.\n       * @param {Object} attrs    Attributes that will be inserted or updated.\n       * @param {Object} options  Options object passed to {@link Model#save save}.\n       * @returns {Promise}\n       */\n\n      /**\n       * Creating event.\n       *\n       * Fired before `insert` query. A promise may be\n       * returned from the event handler for async behaviour. Throwing an\n       * exception from the handler will cancel the save operation.\n       *\n       * @event Model#creating\n       * @param {Model}  model    The model firing the event.\n       * @param {Object} attrs    Attributes that will be inserted.\n       * @param {Object} options  Options object passed to {@link Model#save save}.\n       * @returns {Promise}\n       */\n\n      /**\n       * Updating event.\n       *\n       * Fired before `update` query. A promise may be\n       * returned from the event handler for async behaviour. Throwing an\n       * exception from the handler will cancel the save operation.\n       *\n       * @event Model#updating\n       * @param {Model}  model    The model firing the event.\n       * @param {Object} attrs    Attributes that will be updated.\n       * @param {Object} options  Options object passed to {@link Model#save save}.\n       * @returns {Promise}\n       */\n      return this.triggerThen(method === 'insert' ? 'creating saving' : 'updating saving', this, attrs, options).bind(this).then(function () {\n        return sync[options.method](method === 'update' && options.patch ? attrs : this.attributes);\n      }).then(function (resp) {\n\n        // After a successful database save, the id is updated if the model was created\n        if (method === 'insert' && this.id == null) {\n          var updatedCols = {};\n          updatedCols[this.idAttribute] = this.id = resp[0];\n          var updatedAttrs = this.parse(updatedCols);\n          _lodash2.default.assign(this.attributes, updatedAttrs);\n        } else if (method === 'update' && resp === 0) {\n          if (options.require !== false) {\n            throw new this.constructor.NoRowsUpdatedError('No Rows Updated');\n          }\n        }\n\n        // In case we need to reference the `previousAttributes` for the this\n        // in the following event handlers.\n        options.previousAttributes = this._previousAttributes;\n\n        this._reset();\n\n        /**\n         * Saved event.\n         *\n         * Fired after an `insert` or `update` query.\n         *\n         * @event Model#saved\n         * @param {Model}  model    The model firing the event.\n         * @param {Object} resp     The database response.\n         * @param {Object} options  Options object passed to {@link Model#save save}.\n         * @returns {Promise}\n         */\n\n        /**\n         * Created event.\n         *\n         * Fired after an `insert` query.\n         *\n         * @event Model#created\n         * @param {Model}  model    The model firing the event.\n         * @param {Object} attrs    Model firing the event.\n         * @param {Object} options  Options object passed to {@link Model#save save}.\n         * @returns {Promise}\n         */\n\n        /**\n         * Updated event.\n         *\n         * Fired after an `update` query.\n         *\n         * @event Model#updated\n         * @param {Model}  model    The model firing the event.\n         * @param {Object} attrs    Model firing the event.\n         * @param {Object} options  Options object passed to {@link Model#save save}.\n         * @returns {Promise}\n         */\n        return this.triggerThen(method === 'insert' ? 'created saved' : 'updated saved', this, resp, options);\n      });\n    }).return(this);\n  }),\n\n  /**\n   * `destroy` performs a `delete` on the model, using the model's {@link\n   * Model#idAttribute idAttribute} to constrain the query.\n   *\n   * A {@link Model#destroying \"destroying\"} event is triggered on the model before being\n   * destroyed. To prevent destroying the model (with validation, etc.), throwing an error\n   * inside one of these event listeners will stop destroying the model and\n   * reject the promise.\n   *\n   * A {@link Model#destroyed \"destroyed\"} event is fired after the model's\n   * removal is completed.\n   *\n   * @method Model#destroy\n   *\n   * @param {Object=}      options                  Hash of options.\n   * @param {Transaction=} options.transacting      Optionally run the query in a transaction.\n   * @param {bool} [options.require=true]\n   *   Throw a {@link Model.NoRowsDeletedError} if no records are affected by destroy.\n   *\n   * @example\n   *\n   * new User({id: 1})\n   *   .destroy()\n   *   .then(function(model) {\n   *     // ...\n   *   });\n   *\n   * @fires Model#destroying\n   * @fires Model#destroyed\n   *\n   * @throws {Model.NoRowsDeletedError}\n   *\n   * @returns {Promise<Model>} A promise resolving to the destroyed and thus \"empty\" model.\n   */\n  destroy: _promise2.default.method(function (options) {\n    options = options ? _lodash2.default.clone(options) : {};\n    var sync = this.sync(options);\n    options.query = sync.query;\n    return _promise2.default.bind(this).then(function () {\n\n      /**\n       * Destroying event.\n       *\n       * Fired before a `delete` query. A promise may be returned from the event\n       * handler for async behaviour. Throwing an exception from the handler\n       * will reject the promise and cancel the deletion.\n       *\n       * @event Model#destroying\n       * @param {Model}  model    The model firing the event.\n       * @param {Object} options  Options object passed to {@link Model#save save}.\n       * @returns {Promise}\n       */\n      return this.triggerThen('destroying', this, options);\n    }).then(function () {\n      return sync.del();\n    }).then(function (resp) {\n      if (options.require && resp === 0) {\n        throw new this.constructor.NoRowsDeletedError('No Rows Deleted');\n      }\n      this.clear();\n\n      /**\n       * Destroyed event.\n       *\n       * Fired before a `delete` query. A promise may be returned from the event\n       * handler for async behaviour.\n       *\n       * @event Model#destroyed\n       * @param {Model}  model    The model firing the event.\n       * @param {Object} attrs    Model firing the event.\n       * @param {Object} options  Options object passed to {@link Model#save save}.\n       * @returns {Promise}\n       */\n      return this.triggerThen('destroyed', this, resp, options);\n    }).then(this._reset);\n  }),\n\n  /**\n   *  Used to reset the internal state of the current query builder instance.\n   *  This method is called internally each time a database action is completed\n   *  by {@link Sync}\n   *\n   *  @method Model#resetQuery\n   *  @returns {Model}          Self, this method is chainable.\n   */\n  resetQuery: function resetQuery() {\n    this._knex = null;\n    return this;\n  },\n\n\n  /**\n   * The `query` method is used to tap into the underlying Knex query builder\n   * instance for the current model. If called with no arguments, it will\n   * return the query builder directly. Otherwise, it will call the specified\n   * method on the query builder, applying any additional arguments from the\n   * `model.query` call. If the method argument is a function, it will be\n   * called with the Knex query builder as the context and the first argument,\n   * returning the current model.\n   *\n   * @example\n   *\n   * model\n   *   .query('where', 'other_id', '=', '5')\n   *   .fetch()\n   *   .then(function(model) {\n   *     // ...\n   *   });\n   *\n   * model\n   *   .query({where: {other_id: '5'}, orWhere: {key: 'value'}})\n   *   .fetch()\n   *   .then(function(model) {\n   *     // ...\n   *   });\n   *\n   * model.query(function(qb) {\n   *   qb.where('other_person', 'LIKE', '%Demo').orWhere('other_id', '>', 10);\n   * }).fetch()\n   *   .then(function(model) {\n   *     // ...\n   *   });\n   *\n   * let qb = model.query();\n   * qb.where({id: 1}).select().then(function(resp) {\n   *   // ...\n   * });\n   *\n   * @method Model#query\n   * @param {function|Object|...string=} arguments The query method.\n   * @returns {Model|QueryBuilder}\n   *   Will return this model or, if called with no arguments, the underlying query builder.\n   *\n   * @see {@link http://knexjs.org/#Builder Knex `QueryBuilder`}\n   */\n  query: function query() {\n    return _helpers2.default.query(this, _lodash2.default.toArray(arguments));\n  },\n\n\n  /**\n   * The where method is used as convenience for the most common {@link\n   * Model#query query} method, adding a where clause to the builder. Any\n   * additional knex methods may be accessed using {@link Model#query query}.\n   *\n   * Accepts either key, value syntax, or a hash of attributes.\n   *\n   * @example\n   *\n   * model.where('favorite_color', '<>', 'green').fetch().then(function() { //...\n   * // or\n   * model.where('favorite_color', 'red').fetch().then(function() { //...\n   * // or\n   * model.where({favorite_color: 'red', shoe_size: 12}).fetch().then(function() { //...\n   *\n   * @method Model#where\n   * @param {Object|...string} method\n   *\n   *   Either `key, [operator], value` syntax, or a hash of attributes to\n   *   match. Note that these must be formatted as they are in the database,\n   *   not how they are stored after {@link Model#parse}.\n   *\n   * @returns {Model} Self, this method is chainable.\n   *\n   * @see Model#query\n   */\n  where: function where() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return this.query.apply(this, ['where'].concat(args));\n  },\n\n\n  /**\n   * @method Model#orderBy\n   * @since 0.9.3\n   * @description\n   *\n   * Specifies the column to sort on and sort order.\n   *\n   * The order parameter is optional, and defaults to 'ASC'. You may\n   * also specify 'DESC' order by prepending a hyphen to the sort column\n   * name. `orderBy(\"date\", 'DESC')` is the same as `orderBy(\"-date\")`.\n   *\n   * Unless specified using dot notation (i.e., \"table.column\"), the default\n   * table will be the table name of the model `orderBy` was called on.\n   *\n   * @example\n   *\n   * Car.forge().orderBy('color', 'ASC').fetchAll()\n   *    .then(function (rows) { // ...\n   *\n   * @param sort {string}\n   *   Column to sort on\n   * @param order {string}\n   *   Ascending ('ASC') or descending ('DESC') order\n   */\n  orderBy: function orderBy() {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return _helpers2.default.orderBy.apply(_helpers2.default, [this].concat(args));\n  },\n\n\n  /* Ensure that QueryBuilder is copied on clone. */\n  clone: function clone() {\n    // This needs to use the direct apply method because the spread operator\n    // incorrectly converts to `clone.apply(ModelBase.prototype, arguments)`\n    // instead of `apply(this, arguments)`\n    var cloned = BookshelfModel.__super__.clone.apply(this, arguments);\n    if (this._knex != null) {\n      cloned._knex = cloned._builder(this._knex.clone());\n    }\n    return cloned;\n  },\n\n\n  /**\n   * Creates and returns a new Bookshelf.Sync instance.\n   *\n   * @method Model#sync\n   * @private\n   * @returns Sync\n   */\n  sync: function sync(options) {\n    return new _sync2.default(this, options);\n  },\n\n\n  /**\n   * Helper for setting up the `morphOne` or `morphMany` relations.\n   *\n   * @method Model#_morphOneOrMany\n   * @private\n   */\n  _morphOneOrMany: function _morphOneOrMany(Target, morphName, columnNames, morphValue, type) {\n    if (!_lodash2.default.isArray(columnNames)) {\n      // Shift by one place\n      morphValue = columnNames;\n      columnNames = null;\n    }\n    if (!morphName || !Target) throw new Error('The polymorphic `name` and `Target` are required.');\n    return this._relation(type, Target, { morphName: morphName, morphValue: morphValue, columnNames: columnNames }).init(this);\n  },\n\n\n  /**\n   * @name Model#_handleResponse\n   * @private\n   * @description\n   *\n   *   Handles the response data for the model, returning from the model's fetch call.\n   *\n   * @param {Object} Response from Knex query.\n   *\n   * @todo: need to check on Backbone's status there, ticket #2636\n   * @todo: {silent: true, parse: true}, for parity with collection#set\n   */\n  _handleResponse: function _handleResponse(response) {\n    var relatedData = this.relatedData;\n    this.set(this.parse(response[0]), { silent: true })._reset();\n    if (relatedData && relatedData.isJoined()) {\n      relatedData.parsePivot([this]);\n    }\n  },\n\n\n  /**\n   * @name Model#_handleEager\n   * @private\n   * @description\n   *\n   *   Handles the related data loading on the model.\n   *\n   * @param {Object} Response from Knex query.\n   */\n  _handleEager: function _handleEager(response, options) {\n    return new _eager2.default([this], response, this).fetch(options);\n  }\n}, {\n  extended: function extended(child) {\n    /**\n     * @class Model.NotFoundError\n     * @description\n     *\n     *   Thrown when no records are found by {@link Model#fetch fetch} or\n     *   {@link Model#refresh} when called with the\n     *   `{require: true}` option.\n     */\n    child.NotFoundError = (0, _createError2.default)(this.NotFoundError);\n\n    /**\n     * @class Model.NoRowsUpdatedError\n     * @description\n     *\n     *   Thrown when no records are saved by {@link Model#save save}\n     *   unless called with the `{require: false}` option.\n     */\n    child.NoRowsUpdatedError = (0, _createError2.default)(this.NoRowsUpdatedError);\n\n    /**\n     * @class Model.NoRowsDeletedError\n     * @description\n     *\n     *   Thrown when no record is deleted by {@link Model#destroy destroy}\n     *   if called with the `{require: true}` option.\n     */\n    child.NoRowsDeletedError = (0, _createError2.default)(this.NoRowsDeletedError);\n  }\n});\n\nBookshelfModel.NotFoundError = _errors2.default.NotFoundError;\nBookshelfModel.NoRowsUpdatedError = _errors2.default.NoRowsUpdatedError;\nBookshelfModel.NoRowsDeletedError = _errors2.default.NoRowsDeletedError;\n\nmodule.exports = BookshelfModel;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/sync.js":"'use strict';\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _promise = require('./base/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Sync is the dispatcher for any database queries,\n// taking the \"syncing\" `model` or `collection` being queried, along with\n// a hash of options that are used in the various query methods.\n// If the `transacting` option is set, the query is assumed to be\n// part of a transaction, and this information is passed along to `Knex`.\n// Sync\n// ---------------\nvar Sync = function Sync(syncing, options) {\n  options = options || {};\n  this.query = syncing.query();\n  this.syncing = syncing.resetQuery();\n  this.options = options;\n  if (options.debug) this.query.debug();\n  if (options.transacting) this.query.transacting(options.transacting);\n};\n\n_lodash2.default.extend(Sync.prototype, {\n\n  // Prefix all keys of the passed in object with the\n  // current table name\n  prefixFields: function prefixFields(fields) {\n    var tableName = this.syncing.tableName;\n    var prefixed = {};\n    for (var key in fields) {\n      prefixed[tableName + '.' + key] = fields[key];\n    }\n    return prefixed;\n  },\n\n  // Select the first item from the database - only used by models.\n  first: _promise2.default.method(function (attributes) {\n\n    var model = this.syncing;\n    var query = this.query;\n\n    // We'll never use an JSON object for a search, because even\n    // PostgreSQL, which has JSON type columns, does not support the `=`\n    // operator.\n    //\n    // NOTE: `_.omit` returns an empty object, even if attributes are null.\n    var whereAttributes = _lodash2.default.omitBy(attributes, _lodash2.default.isPlainObject);\n\n    if (!_lodash2.default.isEmpty(whereAttributes)) {\n\n      // Format and prefix attributes.\n      var formatted = this.prefixFields(model.format(whereAttributes));\n      query.where(formatted);\n    }\n\n    // Limit to a single result.\n    query.limit(1);\n\n    return this.select();\n  }),\n\n  // Runs a `count` query on the database, adding any necessary relational\n  // constraints. Returns a promise that resolves to an integer count.\n  count: _promise2.default.method(function (column) {\n    var knex = this.query,\n        options = this.options,\n        relatedData = this.syncing.relatedData,\n        fks = {};\n\n    return _promise2.default.bind(this).then(function () {\n      // Inject all appropriate select costraints dealing with the relation\n      // into the `knex` query builder for the current instance.\n      if (relatedData) return _promise2.default.try(function () {\n        if (relatedData.isThrough()) {\n          fks[relatedData.key('foreignKey')] = relatedData.parentFk;\n          var through = new relatedData.throughTarget(fks);\n          relatedData.pivotColumns = through.parse(relatedData.pivotColumns);\n        } else if (relatedData.type === 'hasMany') {\n          var fk = relatedData.key('foreignKey');\n          knex.where(fk, relatedData.parentFk);\n        }\n      });\n    }).then(function () {\n      options.query = knex;\n\n      /**\n       * Counting event.\n       *\n       * Fired before a `count` query. A promise may be\n       * returned from the event handler for async behaviour.\n       *\n       * @event Model#counting\n       * @param {Model}  model    The model firing the event.\n       * @param {Object} options  Options object passed to {@link Model#count count}.\n       * @returns {Promise}\n       */\n      return this.syncing.triggerThen('counting', this.syncing, options);\n    }).then(function () {\n      return knex.count((column || '*') + ' as count');\n    }).then(function (rows) {\n      return rows[0].count;\n    });\n  }),\n\n  // Runs a `select` query on the database, adding any necessary relational\n  // constraints, resetting the query when complete. If there are results and\n  // eager loaded relations, those are fetched and returned on the model before\n  // the promise is resolved. Any `success` handler passed in the\n  // options will be called - used by both models & collections.\n  select: _promise2.default.method(function () {\n    var _this = this;\n\n    var knex = this.query;\n    var options = this.options;\n    var relatedData = this.syncing.relatedData;\n    var fks = {};\n    var columns = null;\n\n    // Check if any `select` style statements have been called with column\n    // specifications. This could include `distinct()` with no arguments, which\n    // does not affect inform the columns returned.\n    var queryContainsColumns = (0, _lodash2.default)(knex._statements).filter({ grouping: 'columns' }).some('value.length');\n\n    return _promise2.default.bind(this).then(function () {\n      // Set the query builder on the options, in-case we need to\n      // access in the `fetching` event handlers.\n      options.query = knex;\n\n      // Inject all appropriate select costraints dealing with the relation\n      // into the `knex` query builder for the current instance.\n      if (relatedData) return _promise2.default.try(function () {\n        if (relatedData.isThrough()) {\n          var _ret = function () {\n            fks[relatedData.key('foreignKey')] = relatedData.parentFk;\n            var through = new relatedData.throughTarget(fks);\n\n            return {\n              v: through.triggerThen('fetching', through, relatedData.pivotColumns, options).then(function () {\n                relatedData.pivotColumns = through.parse(relatedData.pivotColumns);\n              })\n            };\n          }();\n\n          if ((typeof _ret === 'undefined' ? 'undefined' : (0, _typeof3.default)(_ret)) === \"object\") return _ret.v;\n        }\n      });\n    }).tap(function () {\n\n      // If this is a relation, apply the appropriate constraints.\n      if (relatedData) {\n        relatedData.selectConstraints(knex, options);\n      } else {\n\n        // Call the function, if one exists, to constrain the eager loaded query.\n        if (options._beforeFn) options._beforeFn.call(knex, knex);\n\n        if (options.columns) {\n\n          // Normalize single column name into array.\n          columns = _lodash2.default.isArray(options.columns) ? options.columns : [options.columns];\n        } else if (!queryContainsColumns) {\n\n          // If columns have already been selected via the `query` method\n          // we will use them. Otherwise, select all columns in this table.\n          columns = [_lodash2.default.result(_this.syncing, 'tableName') + '.*'];\n        }\n      }\n\n      // Set the query builder on the options, for access in the `fetching`\n      // event handlers.\n      options.query = knex;\n\n      /**\n       * Fired before a `fetch` operation. A promise may be returned from the\n       * event handler for async behaviour.\n       *\n       * @event Model#fetching\n       * @param {Model} model\n       *   The model which is about to be fetched.\n       * @param {string[]} columns\n       *   The columns to be retrieved by the query.\n       * @param {Object} options\n       *   Options object passed to {@link Model#fetch fetch}.\n       * @param {QueryBuilder} options.query\n       *   Query builder to be used for fetching. This can be modified to\n       *   change the query before it is executed.\n       *\n       * @returns {Promise}\n       */\n      return _this.syncing.triggerThen('fetching', _this.syncing, columns, options);\n    }).then(function () {\n      return knex.select(columns);\n    });\n  }),\n\n  // Issues an `insert` command on the query - only used by models.\n  insert: _promise2.default.method(function () {\n    var syncing = this.syncing;\n    return this.query.insert(syncing.format(_lodash2.default.extend(Object.create(null), syncing.attributes)), syncing.idAttribute);\n  }),\n\n  // Issues an `update` command on the query - only used by models.\n  update: _promise2.default.method(function (attrs) {\n    var syncing = this.syncing,\n        query = this.query;\n    if (syncing.id != null) query.where(syncing.idAttribute, syncing.id);\n    if (_lodash2.default.filter(query._statements, { grouping: 'where' }).length === 0) {\n      throw new Error('A model cannot be updated without a \"where\" clause or an idAttribute.');\n    }\n    return query.update(syncing.format(_lodash2.default.extend(Object.create(null), attrs)));\n  }),\n\n  // Issues a `delete` command on the query.\n  del: _promise2.default.method(function () {\n    var query = this.query,\n        syncing = this.syncing;\n    if (syncing.id != null) query.where(syncing.idAttribute, syncing.id);\n    if (_lodash2.default.filter(query._statements, { grouping: 'where' }).length === 0) {\n      throw new Error('A model cannot be destroyed without a \"where\" clause or an idAttribute.');\n    }\n    return this.query.del();\n  })\n\n});\n\nmodule.exports = Sync;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/eager.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require('babel-runtime/helpers/inherits');\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nvar _promise = require('./base/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _eager = require('./base/eager');\n\nvar _eager2 = _interopRequireDefault(_eager);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// EagerRelation\n// ---------------\nvar getAttributeUnique = function getAttributeUnique(models, attribute) {\n  return _lodash2.default.uniq(_lodash2.default.map(models, function (m) {\n    return m.get(attribute);\n  }));\n};\n\n// An `EagerRelation` object temporarily stores the models from an eager load,\n// and handles matching eager loaded objects with their parent(s). The\n// `tempModel` is only used to retrieve the value of the relation method, to\n// know the constraints for the eager query.\n\nvar EagerRelation = function (_EagerBase) {\n  (0, _inherits3.default)(EagerRelation, _EagerBase);\n\n  function EagerRelation() {\n    (0, _classCallCheck3.default)(this, EagerRelation);\n    return (0, _possibleConstructorReturn3.default)(this, (EagerRelation.__proto__ || Object.getPrototypeOf(EagerRelation)).apply(this, arguments));\n  }\n\n  (0, _createClass3.default)(EagerRelation, [{\n    key: 'eagerFetch',\n\n\n    // Handles an eager loaded fetch, passing the name of the item we're fetching\n    // for, and any options needed for the current fetch.\n    value: function eagerFetch(relationName, handled, options) {\n      var _this2 = this;\n\n      var relatedData = handled.relatedData;\n\n      // skip eager loading for rows where the foreign key isn't set\n      if (relatedData.parentFk === null) return;\n\n      if (relatedData.type === 'morphTo') {\n        return this.morphToFetch(relationName, relatedData, options);\n      }\n\n      return handled.sync((0, _extends3.default)({}, options, { parentResponse: this.parentResponse })).select().tap(function (response) {\n        return _this2._eagerLoadHelper(response, relationName, handled, _lodash2.default.omit(options, 'parentResponse'));\n      });\n    }\n\n    // Special handler for the eager loaded morph-to relations, this handles the\n    // fact that there are several potential models that we need to be fetching\n    // against.  pairing them up onto a single response for the eager loading.\n\n  }, {\n    key: 'morphToFetch',\n    value: function morphToFetch(relationName, relatedData, options) {\n      var _this3 = this;\n\n      var columnNames = relatedData.columnNames || [];\n      var morphName = relatedData.morphName;\n\n      var _columnNames = (0, _slicedToArray3.default)(columnNames, 2),\n          _columnNames$ = _columnNames[0],\n          typeColumn = _columnNames$ === undefined ? morphName + '_type' : _columnNames$,\n          _columnNames$2 = _columnNames[1],\n          idColumn = _columnNames$2 === undefined ? morphName + '_id' : _columnNames$2;\n\n      var parentsByType = _lodash2.default.groupBy(this.parent, function (model) {\n        return model.get(typeColumn);\n      });\n      var TargetByType = _lodash2.default.mapValues(parentsByType, function (parents, type) {\n        return _helpers2.default.morphCandidate(relatedData.candidates, type);\n      });\n\n      return _promise2.default.all(_lodash2.default.map(parentsByType, function (parents, type) {\n        var Target = TargetByType[type];\n        var idAttribute = _lodash2.default.result(Target.prototype, 'idAttribute');\n        var ids = getAttributeUnique(parents, idColumn);\n\n        return Target.query('whereIn', idAttribute, ids).sync(options).select().tap(function (response) {\n          var clone = relatedData.instance('morphTo', Target, { morphName: morphName, columnNames: columnNames });\n          return _this3._eagerLoadHelper(response, relationName, { relatedData: clone }, options);\n        });\n      })).then(_lodash2.default.flatten);\n    }\n\n    // Handles the eager load for both the `morphTo` and regular cases.\n\n  }, {\n    key: '_eagerLoadHelper',\n    value: function _eagerLoadHelper(response, relationName, handled, options) {\n      var _this4 = this;\n\n      var relatedModels = this.pushModels(relationName, handled, response);\n      var relatedData = handled.relatedData;\n\n      return _promise2.default.try(function () {\n        // If there is a response, fetch additional nested eager relations, if any.\n        if (response.length > 0 && options.withRelated) {\n          var relatedModel = relatedData.createModel();\n\n          // If this is a `morphTo` relation, we need to do additional processing\n          // to ensure we don't try to load any relations that don't look to exist.\n          if (relatedData.type === 'morphTo') {\n            var withRelated = _this4._filterRelated(relatedModel, options);\n            if (withRelated.length === 0) return;\n            options = _lodash2.default.extend({}, options, { withRelated: withRelated });\n          }\n          return new EagerRelation(relatedModels, response, relatedModel).fetch(options).return(response);\n        }\n      }).tap(function () {\n        return _promise2.default.map(relatedModels, function (model) {\n          return model.triggerThen('fetched', model, model.attributes, options);\n        });\n      });\n    }\n\n    // Filters the `withRelated` on a `morphTo` relation, to ensure that only valid\n    // relations are attempted for loading.\n\n  }, {\n    key: '_filterRelated',\n    value: function _filterRelated(relatedModel, options) {\n\n      // By this point, all withRelated should be turned into a hash, so it should\n      // be fairly simple to process by splitting on the dots.\n      return _lodash2.default.reduce(options.withRelated, function (memo, val) {\n        for (var key in val) {\n          var seg = key.split('.')[0];\n          if (_lodash2.default.isFunction(relatedModel[seg])) memo.push(val);\n        }\n        return memo;\n      }, []);\n    }\n  }]);\n  return EagerRelation;\n}(_eager2.default);\n\nexports.default = EagerRelation;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/base/eager.js":"'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _promise = require('./promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Eager Base\n// ---------------\n\n// The EagerBase provides a scaffold for handling with eager relation\n// pairing, by queueing the appropriate related method calls with\n// a database specific `eagerFetch` method, which then may utilize\n// `pushModels` for pairing the models depending on the database need.\n\nfunction EagerBase(parent, parentResponse, target) {\n  this.parent = parent;\n  this.parentResponse = parentResponse;\n  this.target = target;\n}\n\n_lodash2.default.extend(EagerBase.prototype, {\n\n  // This helper function is used internally to determine which relations\n  // are necessary for fetching based on the `model.load` or `withRelated` option.\n  fetch: _promise2.default.method(function (options) {\n    var target = this.target;\n    var handled = this.handled = {};\n    var withRelated = this.prepWithRelated(options.withRelated);\n    var subRelated = {};\n\n    // Internal flag to determine whether to set the ctor(s) on the `Relation` object.\n    target._isEager = true;\n\n    // Eager load each of the `withRelated` relation item, splitting on '.'\n    // which indicates a nested eager load.\n    for (var key in withRelated) {\n      var related = key.split('.');\n      var relationName = related[0];\n\n      // Add additional eager items to an array, to load at the next level in the query.\n      if (related.length > 1) {\n        var relatedObj = {};\n        subRelated[relationName] = subRelated[relationName] || [];\n        relatedObj[related.slice(1).join('.')] = withRelated[key];\n        subRelated[relationName].push(relatedObj);\n      }\n\n      // Only allow one of a certain nested type per-level.\n      if (handled[relationName]) continue;\n\n      if (!_lodash2.default.isFunction(target[relationName])) {\n        throw new Error(relationName + ' is not defined on the model.');\n      }\n\n      var relation = target[relationName]();\n\n      handled[relationName] = relation;\n    }\n\n    // Delete the internal flag from the model.\n    delete target._isEager;\n\n    // Fetch all eager loaded models, loading them onto\n    // an array of pending deferred objects, which will handle\n    // all necessary pairing with parent objects, etc.\n    var pendingDeferred = [];\n    for (var _relationName in handled) {\n      pendingDeferred.push(this.eagerFetch(_relationName, handled[_relationName], _lodash2.default.extend({}, options, {\n        isEager: true,\n        withRelated: subRelated[_relationName],\n        _beforeFn: withRelated[_relationName] || _lodash.noop\n      })));\n    }\n\n    // Return a deferred handler for all of the nested object sync\n    // returning the original response when these syncs & pairings are complete.\n    return _promise2.default.all(pendingDeferred).return(this.parentResponse);\n  }),\n\n  // Prep the `withRelated` object, to normalize into an object where each\n  // has a function that is called when running the query.\n  prepWithRelated: function prepWithRelated(withRelated) {\n    if (!_lodash2.default.isArray(withRelated)) withRelated = [withRelated];\n    var obj = {};\n    for (var i = 0, l = withRelated.length; i < l; i++) {\n      var related = withRelated[i];\n      if (_lodash2.default.isString(related)) {\n        obj[related] = _lodash.noop;\n      } else {\n        _lodash2.default.extend(obj, related);\n      }\n    }\n    return obj;\n  },\n\n  // Pushes each of the incoming models onto a new `related` array,\n  // which is used to correcly pair additional nested relations.\n  pushModels: function pushModels(relationName, handled, response) {\n    var models = this.parent;\n    var relatedData = handled.relatedData;\n\n    var related = (0, _lodash.map)(response, function (row) {\n      return relatedData.createModel(row);\n    });\n    return relatedData.eagerPair(relationName, related, models);\n  }\n\n});\n\nmodule.exports = EagerBase;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/errors.js":"'use strict';\n\nvar _createError = require('create-error');\n\nvar _createError2 = _interopRequireDefault(_createError);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n\n  // Thrown when the model is not found and {require: true} is passed in the fetch options\n  NotFoundError: (0, _createError2.default)('NotFoundError'),\n\n  // Thrown when the collection is empty and {require: true} is passed in model.fetchAll or\n  // collection.fetch\n  EmptyError: (0, _createError2.default)('EmptyError'),\n\n  // Thrown when an update affects no rows and {require: true} is passed in model.save.\n  NoRowsUpdatedError: (0, _createError2.default)('NoRowsUpdatedError'),\n\n  // Thrown when a delete affects no rows and {require: true} is passed in model.destroy.\n  NoRowsDeletedError: (0, _createError2.default)('NoRowsDeletedError')\n\n};","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/base/model.js":"'use strict';\n\nvar _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _extends2 = require('babel-runtime/helpers/extends');\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _typeof2 = require('babel-runtime/helpers/typeof');\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _inherits = require('inherits');\n\nvar _inherits2 = _interopRequireDefault(_inherits);\n\nvar _events = require('./events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PIVOT_PREFIX = '_pivot_'; // Base Model\n// ---------------\n\nvar DEFAULT_TIMESTAMP_KEYS = ['created_at', 'updated_at'];\n\n// List of attributes attached directly from the `options` passed to the constructor.\nvar modelProps = ['tableName', 'hasTimestamps'];\n\n/**\n * @class\n * @classdesc\n * @extends Events\n * @inheritdoc\n * @description\n *\n * The \"ModelBase\" is similar to the 'Active Model' in Rails, it defines a\n * standard interface from which other objects may inherit.\n */\nfunction ModelBase(attributes, options) {\n  var attrs = attributes || {};\n  options = options || {};\n  this.attributes = Object.create(null);\n  this._reset();\n  this.relations = {};\n  this.cid = _lodash2.default.uniqueId('c');\n  if (options) {\n    _lodash2.default.extend(this, _lodash2.default.pick(options, modelProps));\n    if (options.parse) attrs = this.parse(attrs, options) || {};\n  }\n  this.set(attrs, options);\n  this.initialize.apply(this, arguments);\n}\n\n/**\n * @method ModelBase#on\n * @example\n *\n * customer.on('fetching', function(model, columns) {\n *   // Do something before the data is fetched from the database\n * });\n *\n * @see Events#on\n */\n\n/**\n * @method ModelBase#off\n * @example\n *\n * customer.off('fetched fetching');\n * ship.off(); // This will remove all event listeners\n *\n * @see Events#off\n */\n\n/**\n * @method ModelBase#trigger\n * @example\n *\n * ship.trigger('fetched');\n *\n * @see Events#trigger\n */\n(0, _inherits2.default)(ModelBase, _events2.default);\n\n/**\n * @method ModelBase#initialize\n * @description\n *\n * Called by the {@link Model Model constructor} when creating a new instance.\n * Override this function to add custom initialization, such as event listeners.\n *\n * @see Model\n *\n * @param {Object} attributes\n *   Initial values for this model's attributes.\n * @param {Object=}  options\n *   The hash of options passed to {@link Model constructor}.\n */\nModelBase.prototype.initialize = function () {};\n\n/**\n * @name ModelBase#tableName\n * @member {string}\n * @description\n *\n * A required property for any database usage, The\n * {@linkcode Model#tableName tableName} property refers to the database\n * table name the model will query against.\n *\n * @example\n *\n * var Television = bookshelf.Model.extend({\n *   tableName: 'televisions'\n * });\n */\n\n/**\n * @member {string}\n * @default \"id\"\n * @description\n *\n * This tells the model which attribute to expect as the unique identifier\n * for each database row (typically an auto-incrementing primary key named\n * `\"id\"`). Note that if you are using {@link Model#parse parse} and {@link\n * Model#format format} (to have your model's attributes in `camelCase`,\n * but your database's columns in `snake_case`, for example) this refers to\n * the name returned by parse (`myId`), not the database column (`my_id`).\n *\n */\nModelBase.prototype.idAttribute = 'id';\n\n/**\n * @member {boolean|Array}\n * @default false\n * @description\n *\n * Sets the current date/time on the timestamps columns `created_at` and\n * `updated_at` for a given method. The 'update' method will only update\n * `updated_at`.  To override the default column names, assign an array\n * to {@link Model#hasTimestamps hasTimestamps}.  The first element will\n * be the created column name and the second will be the updated\n * column name.\n *\n */\nModelBase.prototype.hasTimestamps = false;\n\n/**\n * @method\n * @description  Get the current value of an attribute from the model.\n * @example      note.get(\"title\");\n *\n * @param {string} attribute - The name of the attribute to retrieve.\n * @returns {mixed} Attribute value.\n */\nModelBase.prototype.get = function (attr) {\n  return this.attributes[attr];\n};\n\n/**\n * @method\n * @description  Set a hash of attributes (one or many) on the model.\n * @example\n *\n * customer.set({first_name: \"Joe\", last_name: \"Customer\"});\n * customer.set(\"telephone\", \"555-555-1212\");\n *\n * @param {string|Object} attribute Attribute name, or hash of attribute names and values.\n * @param {mixed=} value If a string was provided for `attribute`, the value to be set.\n * @param {Object=} options\n * @param {Object} [options.unset=false] Remove attributes from the model instead of setting them.\n * @returns {Model} This model.\n */\nModelBase.prototype.set = function (key, val, options) {\n  if (key == null) return this;\n  var attrs = void 0;\n\n  // Handle both `\"key\", value` and `{key: value}` -style arguments.\n  if ((typeof key === 'undefined' ? 'undefined' : (0, _typeof3.default)(key)) === 'object') {\n    attrs = key;\n    options = val;\n  } else {\n    (attrs = {})[key] = val;\n  }\n  options = (0, _lodash.clone)(options) || {};\n\n  // Extract attributes and options.\n  var unset = options.unset;\n  var current = this.attributes;\n  var prev = this._previousAttributes;\n\n  // Check for changes of `id`.\n  if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];\n\n  // For each `set` attribute, update or delete the current value.\n  for (var attr in attrs) {\n    val = attrs[attr];\n    if (!_lodash2.default.isEqual(prev[attr], val)) {\n      this.changed[attr] = val;\n    } else {\n      delete this.changed[attr];\n    }\n    if (unset) {\n      delete current[attr];\n    } else {\n      current[attr] = val;\n    }\n  }\n  return this;\n};\n\n/**\n * @method\n * @description\n *\n * Checks for the existence of an id to determine whether the model is\n * considered \"new\".\n *\n * @example\n *\n * var modelA = new bookshelf.Model();\n * modelA.isNew(); // true\n *\n * var modelB = new bookshelf.Model({id: 1});\n * modelB.isNew(); // false\n */\nModelBase.prototype.isNew = function () {\n  return this.id == null;\n};\n\n/**\n * @method\n * @description\n *\n * Return a copy of the model's {@link Model#attributes attributes} for JSON\n * stringification. If the {@link Model model} has any relations defined, this\n * will also call {@link Model#toJSON toJSON} on each of the related\n * objects, and include them on the object unless `{shallow: true}` is\n * passed as an option.\n *\n * `serialize` is called internally by {@link Model#toJSON toJSON}. Override\n * this function if you want to customize its output.\n *\n * @example\n * var artist = new bookshelf.Model({\n *   firstName: \"Wassily\",\n *   lastName: \"Kandinsky\"\n * });\n *\n * artist.set({birthday: \"December 16, 1866\"});\n *\n * console.log(JSON.stringify(artist));\n * // {firstName: \"Wassily\", lastName: \"Kandinsky\", birthday: \"December 16, 1866\"}\n *\n * @param {Object=} options\n * @param {bool}    [options.shallow=false]   Exclude relations.\n * @param {bool}    [options.omitPivot=false] Exclude pivot values.\n * @returns {Object} Serialized model as a plain object.\n */\nModelBase.prototype.serialize = function () {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$shallow = options.shallow,\n      shallow = _options$shallow === undefined ? false : _options$shallow,\n      _options$omitPivot = options.omitPivot,\n      omitPivot = _options$omitPivot === undefined ? false : _options$omitPivot,\n      _options$omitNew = options.omitNew,\n      omitNew = _options$omitNew === undefined ? false : _options$omitNew;\n  var attributes = this.attributes;\n\n\n  if (omitNew && this.isNew()) {\n    return null;\n  }\n\n  if (!shallow) {\n\n    var relations = (0, _lodash.mapValues)(this.relations, function (relation, key) {\n      return relation.toJSON != null ? relation.toJSON(options) : relation;\n    });\n\n    // Omit null relations from the omitNew option\n    relations = _lodash2.default.omitBy(relations, _lodash2.default.isNull);\n\n    var pivot = this.pivot && !omitPivot && this.pivot.attributes;\n    var pivotAttributes = (0, _lodash.mapKeys)(pivot, function (value, key) {\n      return '' + PIVOT_PREFIX + key;\n    });\n\n    return (0, _extends3.default)({}, attributes, relations, pivotAttributes);\n  }\n\n  return (0, _extends3.default)({}, attributes);\n};\n\n/**\n * @method\n * @description\n *\n * Called automatically by {@link\n * https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior\n * `JSON.stringify`}. To customize serialization, override {@link\n * Model#serialize serialize}.\n *\n * @param {Object=} options Options passed to {@link Model#serialize}.\n */\nModelBase.prototype.toJSON = function (options) {\n  return this.serialize(options);\n};\n\n/**\n * @method\n * @private\n * @returns String representation of the object.\n */\nModelBase.prototype.toString = function () {\n  return '[Object Model]';\n};\n\n/**\n * @method\n * @description Get the HTML-escaped value of an attribute.\n * @param {string} attribute The attribute to escape.\n * @returns {string} HTML-escaped value of an attribute.\n */\nModelBase.prototype.escape = function (key) {\n  return _lodash2.default.escape(this.get(key));\n};\n\n/**\n * @method\n * @description\n * Returns `true` if the attribute contains a value that is not null or undefined.\n * @param {string} attribute The attribute to check.\n * @returns {bool} True if `attribute` is set, otherwise null.\n */\nModelBase.prototype.has = function (attr) {\n  return this.get(attr) != null;\n};\n\n/**\n * @method\n * @description\n *\n * The parse method is called whenever a {@link Model model}'s data is returned\n * in a {@link Model#fetch fetch} call. The function is passed the raw database\n * response object, and should return the {@link Model#attributes\n * attributes} hash to be {@link Model#set set} on the model. The default\n * implementation is a no-op, simply passing through the JSON response.\n * Override this if you need to format the database responses - for example\n * calling {@link\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\n * JSON.parse} on a text field containing JSON, or explicitly typecasting a\n * boolean in a sqlite3 database response.\n *\n * @example\n *\n * // Example of a \"parse\" to convert snake_case to camelCase, using `underscore.string`\n * model.parse = function(attrs) {\n *   return _.reduce(attrs, function(memo, val, key) {\n *     memo[_.camelCase(key)] = val;\n *     return memo;\n *   }, {});\n * };\n *\n * @param {Object} response Hash of attributes to parse.\n * @returns {Object} Parsed attributes.\n */\nModelBase.prototype.parse = _lodash.identity;\n\n/**\n * @method\n * @description\n *\n * Remove an attribute from the model. `unset` is a noop if the attribute\n * doesn't exist.\n *\n * Note that unsetting an attribute from the model will not affect the related\n * record's column value when saving the model. In order to clear the value of a\n * column in the database record, set the attribute value to `null` instead:\n * `model.set(\"column_name\", null)`.\n *\n * @param attribute Attribute to unset.\n * @returns {Model} This model.\n */\nModelBase.prototype.unset = function (attr, options) {\n  return this.set(attr, void 0, _lodash2.default.extend({}, options, { unset: true }));\n};\n\n/**\n * @method\n * @description Clear all attributes on the model.\n * @returns {Model} This model.\n */\nModelBase.prototype.clear = function (options) {\n  var undefinedKeys = (0, _lodash.mapValues)(this.attributes, function () {\n    return undefined;\n  });\n  return this.set(undefinedKeys, (0, _extends3.default)({}, options, { unset: true }));\n};\n\n/**\n * @method\n * @description\n *\n * The `format` method is used to modify the current state of the model before\n * it is persisted to the database. The `attributes` passed are a shallow clone\n * of the {@link Model model}, and are only used for inserting/updating - the\n * current values of the model are left intact.\n *\n * @param {Object} attributes The attributes to be converted.\n * @returns {Object} Formatted attributes.\n */\nModelBase.prototype.format = _lodash.identity;\n\n/**\n * @method\n * @description\n *\n * The `related` method returns a specified relation loaded on the relations\n * hash on the model, or calls the associated relation method and adds it to\n * the relations hash if one exists and has not yet been loaded.\n *\n * @example\n *\n * new Photo({id: 1}).fetch({\n *   withRelated: ['account']\n * }).then(function(photo) {\n *   if (photo) {\n *     var account = photo.related('account');\n *     if (account.id) {\n *        return account.related('trips').fetch();\n *     }\n *   }\n * });\n *\n * @param name {string} The name of the relation to retrieve.\n * @returns {Model|Collection|undefined} The specified relation as defined by a\n *   method on the model, or undefined if it does not exist.\n */\nModelBase.prototype.related = function (name) {\n  return this.relations[name] || (this[name] ? this.relations[name] = this[name]() : void 0);\n};\n\n/**\n * @method\n * @description\n * Returns a new instance of the model with identical {@link\n * Model#attributes attributes}, including any relations from the cloned\n * model.\n *\n * @returns {Model} Cloned instance of this model.\n */\nModelBase.prototype.clone = function () {\n  var model = new this.constructor(this.attributes);\n  (0, _lodash.assign)(model.relations, (0, _lodash.mapValues)(this.relations, function (r) {\n    return r.clone();\n  }));\n  model._previousAttributes = (0, _lodash.clone)(this._previousAttributes);\n  model.changed = (0, _lodash.clone)(this.changed);\n  return model;\n};\n\n/**\n * @method\n * @private\n * @description\n *\n * Returns the method that will be used on save, either 'update' or 'insert'.\n * This is an internal helper that uses `isNew` and `options.method` to\n * determine the correct method. If `option.method` is provided, it will be\n * returned, but lowercased for later comparison.\n *\n * @returns {string} Either `'insert'` or `'update'`.\n */\nModelBase.prototype.saveMethod = function () {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$method = _ref.method,\n      method = _ref$method === undefined ? null : _ref$method,\n      _ref$patch = _ref.patch,\n      patch = _ref$patch === undefined ? false : _ref$patch;\n\n  if (patch) {\n    if (method == 'insert') throw new TypeError('Cannot accept incompatible options: methods=' + method + ', patch=' + patch);\n    method = 'update';\n  }\n  return (patch && 'update' || method) == null ? this.isNew() ? 'insert' : 'update' : method.toLowerCase();\n};\n\n/**\n * @method\n * @description\n * Sets the timestamp attributes on the model, if {@link Model#hasTimestamps\n * hasTimestamps} is set to `true` or an array. Check if the model {@link\n * Model#isNew isNew} or if `{method: 'insert'}` is provided as an option and\n * set the `created_at` and `updated_at` attributes to the current date if it\n * is being inserted, and just the `updated_at` attribute if it's being updated.\n * This method may be overriden to use different column names or types for the\n * timestamps.\n *\n * @param {Object=} options\n * @param {string} [options.method]\n *   Either `'insert'` or `'update'`. Specify what kind of save the attribute\n *   update is for.\n *\n * @returns {Object} A hash of timestamp attributes that were set.\n */\nModelBase.prototype.timestamp = function (options) {\n  if (!this.hasTimestamps) return {};\n\n  var now = new Date();\n  var attributes = {};\n  var method = this.saveMethod(options);\n  var keys = _lodash2.default.isArray(this.hasTimestamps) ? this.hasTimestamps : DEFAULT_TIMESTAMP_KEYS;\n\n  var _keys = (0, _slicedToArray3.default)(keys, 2),\n      createdAtKey = _keys[0],\n      updatedAtKey = _keys[1];\n\n  if (updatedAtKey) {\n    attributes[updatedAtKey] = now;\n  }\n\n  if (createdAtKey && method === 'insert') {\n    attributes[createdAtKey] = now;\n  }\n\n  this.set(attributes, options);\n\n  return attributes;\n};\n\n/**\n * @method\n * @description\n *\n * Returns true if any {@link Model#attributes attribute} attribute has changed\n * since the last {@link Model#fetch fetch}, {@link Model#save save}, or {@link\n * Model#destroy destroy}. If an attribute is passed, returns true only if that\n * specific attribute has changed.\n *\n * @param {string=} attribute\n * @returns {bool}\n * `true` if any attribute has changed. Or, if `attribute` was specified, true\n * if it has changed.\n */\nModelBase.prototype.hasChanged = function (attr) {\n  if (attr == null) return !_lodash2.default.isEmpty(this.changed);\n  return _lodash2.default.has(this.changed, attr);\n};\n\n/**\n * @method\n * @description\n *\n * Returns the this previous value of a changed {@link Model#attributes\n * attribute}, or `undefined` if one had not been specified previously.\n *\n * @param {string} attribute The attribute to check\n * @returns {mixed} The previous value\n */\nModelBase.prototype.previous = function (attribute) {\n  return this._previousAttributes[attribute];\n};\n\n/**\n * @method\n * @description\n *\n * Return a copy of the {@link Model model}'s previous attributes from the\n * model's last {@link Model#fetch fetch}, {@link Model#save save}, or {@link\n * Model#destroy destroy}. Useful for getting a diff between versions of a\n * model, or getting back to a valid state after an error occurs.\n *\n * @returns {Object} The attributes as they were before the last change.\n */\nModelBase.prototype.previousAttributes = function () {\n  return (0, _lodash.clone)(this._previousAttributes);\n};\n\n/**\n * @method\n * @private\n * @description\n *\n * Resets the `_previousAttributes` and `changed` hash for the model.\n * Typically called after a `sync` action (save, fetch, delete) -\n *\n * @returns {Model} This model.\n */\nModelBase.prototype._reset = function () {\n  this._previousAttributes = (0, _lodash.clone)(this.attributes);\n  this.changed = Object.create(null);\n  return this;\n};\n\n/**\n * @method ModelBase#keys\n * @see http://lodash.com/docs/#keys\n */\n/**\n * @method ModelBase#values\n * @see http://lodash.com/docs/#values\n */\n/**\n * @method ModelBase#toPairs\n * @see http://lodash.com/docs/#toPairs\n */\n/**\n * @method ModelBase#invert\n * @see http://lodash.com/docs/#invert\n */\n/**\n * @method ModelBase#pick\n * @see http://lodash.com/docs/#pick\n */\n/**\n * @method ModelBase#omit\n * @see http://lodash.com/docs/#omit\n */\n// \"_\" methods that we want to implement on the Model.\nvar modelMethods = ['keys', 'values', 'toPairs', 'invert', 'pick', 'omit'];\n\n// Mix in each \"_\" method as a proxy to `Model#attributes`.\n_lodash2.default.each(modelMethods, function (method) {\n  ModelBase.prototype[method] = function () {\n    return _lodash2.default[method].apply(_lodash2.default, [this.attributes].concat(Array.prototype.slice.call(arguments)));\n  };\n});\n\n/**\n * @method Model.extend\n * @description\n *\n * To create a Model class of your own, you extend {@link Model bookshelf.Model}.\n *\n * `extend` correctly sets up the prototype chain, so subclasses created with\n * `extend` can be further extended and subclassed as far as you like.\n *\n *     var checkit  = require('checkit');\n *     var Promise  = require('bluebird');\n *     var bcrypt   = Promise.promisifyAll(require('bcrypt'));\n *\n *     var Customer = bookshelf.Model.extend({\n *       initialize: function() {\n *         this.on('saving', this.validateSave);\n *       },\n *\n *       validateSave: function() {\n *         return checkit(rules).run(this.attributes);\n *       },\n *\n *       account: function() {\n *         return this.belongsTo(Account);\n *       },\n *     }, {\n *       login: Promise.method(function(email, password) {\n *         if (!email || !password) throw new Error('Email and password are both required');\n *         return new this({email: email.toLowerCase().trim()}).fetch({require: true}).tap(function(customer) {\n *           return bcrypt.compareAsync(password, customer.get('password'))\n *             .then(function(res) {\n *               if (!res) throw new Error('Invalid password');\n *             });\n *         });\n *       })\n *     });\n *\n *     Customer.login(email, password)\n *       .then(function(customer) {\n *         res.json(customer.omit('password'));\n *       }).catch(Customer.NotFoundError, function() {\n *         res.json(400, {error: email + ' not found'});\n *       }).catch(function(err) {\n *         console.error(err);\n *       });\n *\n * _Brief aside on `super`: JavaScript does not provide a simple way to call\n * `super` — the function of the same name defined higher on the prototype\n * chain. If you override a core function like {@link Model#set set}, or {@link\n * Model#save save}, and you want to invoke the parent object's implementation,\n * you'll have to explicitly call it, along these lines:_\n *\n *     var Customer = bookshelf.Model.extend({\n *       set: function() {\n *         // ...\n *         bookshelf.Model.prototype.set.apply(this, arguments);\n *         // ...\n *       }\n *     });\n *\n * @param {Object=} prototypeProperties\n *   Instance methods and properties to be attached to instances of the new\n *   class.\n * @param {Object=} classProperties\n *   Class (ie. static) functions and properties to be attached to the\n *   constructor of the new class.\n * @returns {Function} Constructor for new `Model` subclass.\n */\nModelBase.extend = require('../extend');\n\nmodule.exports = ModelBase;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/extend.js":"'use strict';\n\nvar _lodash = require('lodash');\n\n// Uses a hash of prototype properties and class properties to be extended.\nmodule.exports = function extend(protoProps, staticProps) {\n  var Parent = this;\n\n  // The constructor function for the new subclass is either defined by you\n  // (the \"constructor\" property in your `extend` definition), or defaulted\n  // by us to simply call the parent's constructor.\n  var Child = protoProps && protoProps.hasOwnProperty('constructor') ? protoProps.constructor : function () {\n    return Parent.apply(this, arguments);\n  };\n\n  (0, _lodash.assign)(Child, Parent, staticProps);\n\n  // Set the prototype chain to inherit from `Parent`.\n  Child.prototype = Object.create(Parent.prototype, {\n    constructor: {\n      value: Child,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  if (protoProps) {\n    (0, _lodash.assign)(Child.prototype, protoProps);\n  }\n\n  // Give child access to the parent prototype as part of \"super\"\n  Child.__super__ = Parent.prototype;\n\n  // If there is an \"extended\" function set on the parent,\n  // call it with the extended child object.\n  if ((0, _lodash.isFunction)(Parent.extended)) Parent.extended(Child);\n\n  return Child;\n};","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/collection.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _sync = require('./sync');\n\nvar _sync2 = _interopRequireDefault(_sync);\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nvar _eager = require('./eager');\n\nvar _eager2 = _interopRequireDefault(_eager);\n\nvar _errors = require('./errors');\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _collection = require('./base/collection');\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _promise = require('./base/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _createError = require('create-error');\n\nvar _createError2 = _interopRequireDefault(_createError);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @class Collection\n * @extends CollectionBase\n * @inheritdoc\n * @classdesc\n *\n * Collections are ordered sets of models returned from the database, from a\n * {@link Model#fetchAll fetchAll} call. They may be used with a suite of\n * {@link http://lodash.com/ Lodash} methods.\n *\n * @constructor\n * @description\n *\n * When creating a {@link Collection}, you may choose to pass in the initial\n * array of {@link Model models}. The collection's {@link Collection#comparator\n * comparator} may be included as an option. Passing `false` as the comparator\n * option will prevent sorting. If you define an {@link Collection#initialize\n * initialize} function, it will be invoked when the collection is created.\n *\n * @example\n * let tabs = new TabSet([tab1, tab2, tab3]);\n *\n * @param {(Model[])=} models Initial array of models.\n * @param {Object=} options\n * @param {bool} [options.comparator=false]\n *   {@link Collection#comparator Comparator} for collection, or `false` to disable sorting.\n */\nvar BookshelfCollection = _collection2.default.extend({\n\n  /**\n   * @method Collection#through\n   * @description\n   * Used to define passthrough relationships - `hasOne`, `hasMany`, `belongsTo`\n   * or `belongsToMany`, \"through\" an `Interim` model or collection.\n   *\n   * @param {Model} Interim Pivot model.\n   *\n   * @param {string=} throughForeignKey\n   *\n   *   Foreign key in this collection model. By default, the `foreignKey` is assumed to\n   *   be the singular form of the `Target` model's tableName, followed by `_id` /\n   *   `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} otherKey\n   *\n   *   Foreign key in the `Interim` model. By default, the `otherKey` is assumed to\n   *   be the singular form of this model's tableName, followed by `_id` /\n   *   `_{{{@link Model#idAttribute idAttribute}}}`.\n   *\n   * @param {string=} throughForeignKeyTarget\n   *\n   *   Column in the `Target` model which `throughForeignKey` references, if other\n   *   than `Target` model's `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @param {string=} otherKeyTarget\n   *\n   *   Column in this collection model which `otherKey` references, if other\n   *   than `id` / `{@link Model#idAttribute idAttribute}`.\n   *\n   * @returns {Collection}\n   */\n  through: function through(Interim, throughForeignKey, otherKey, throughForeignKeyTarget, otherKeyTarget) {\n    return this.relatedData.through(this, Interim, {\n      throughForeignKey: throughForeignKey, otherKey: otherKey, throughForeignKeyTarget: throughForeignKeyTarget, otherKeyTarget: otherKeyTarget\n    });\n  },\n\n  /**\n   * @method Collection#fetch\n   * @description\n   * Fetch the default set of models for this collection from the database,\n   * resetting the collection when they arrive. If you wish to trigger an error\n   * if the fetched collection is empty, pass `{require: true}` as one of the\n   * options to the {@link Collection#fetch fetch} call. A {@link\n   * Collection#fetched \"fetched\"} event will be fired when records are\n   * successfully retrieved. If you need to constrain the query performed by\n   * `fetch`, you can call the {@link Collection#query query} method before\n   * calling `fetch`.\n   *\n   * *If you'd like to only fetch specific columns, you may specify a `columns`\n   * property in the options for the `fetch` call.*\n   *\n   * The `withRelated` option may be specified to fetch the models of the\n   * collection, eager loading any specified {@link Relation relations} named on\n   * the model. A single property, or an array of properties can be specified as\n   * a value for the `withRelated` property. The results of these relation\n   * queries will be loaded into a relations property on the respective models,\n   * may be retrieved with the {@link Model#related related} method.\n   *\n   * @fires Collection#fetched\n   * @throws {Collection.EmptyError}\n   *   Upon a sucessful query resulting in no records returns. Only fired if `require: true` is passed as an option.\n   *\n   * @param {Object=} options\n   * @param {bool} [options.require=false] Trigger a {@link Collection.EmptyError} if no records are found.\n   * @param {string|string[]} [options.withRelated=[]] A relation, or list of relations, to be eager loaded as part of the `fetch` operation.\n   * @returns {Promise<Collection>}\n   */\n  fetch: _promise2.default.method(function (options) {\n    options = options ? (0, _lodash.clone)(options) : {};\n    return this.sync(options).select().bind(this).tap(function (response) {\n      if (!response || response.length === 0) {\n        throw new this.constructor.EmptyError('EmptyResponse');\n      }\n    })\n\n    // Now, load all of the data onto the collection as necessary.\n    .tap(this._handleResponse)\n\n    // If the \"withRelated\" is specified, we also need to eager load all of the\n    // data on the collection, as a side-effect, before we ultimately jump into the\n    // next step of the collection. Since the `columns` are only relevant to the current\n    // level, ensure those are omitted from the options.\n    .tap(function (response) {\n      if (options.withRelated) {\n        return this._handleEager(response, (0, _lodash.omit)(options, 'columns'));\n      }\n    }).tap(function (response) {\n\n      /**\n       * @event Collection#fetched\n       *\n       * @description\n       * Fired after a `fetch` operation. A promise may be returned from the\n       * event handler for async behaviour.\n       *\n       * @param {Collection} collection The collection performing the {@link Collection#fetch}.\n       * @param {Object} reponse Knex query response.\n       * @param {Object} options Options object passed to {@link Collection#fetch fetch}.\n       * @returns {Promise}\n       */\n      return this.triggerThen('fetched', this, response, options);\n    }).catch(this.constructor.EmptyError, function (err) {\n      if (options.require) {\n        throw err;\n      }\n      this.reset([], { silent: true });\n    }).return(this);\n  }),\n\n  /**\n   * @method Collection#count\n   * @since 0.8.2\n   * @description\n   *\n   * Get the number of records in the collection's table.\n   *\n   * @example\n   *\n   * // select count(*) from shareholders where company_id = 1 and share &gt; 0.1;\n   * Company.forge({id:1})\n   *   .shareholders()\n   *   .query('where', 'share', '>', '0.1')\n   *   .count()\n   *   .then(function(count) {\n   *     assert(count === 3);\n   *   });\n   *\n   * @param {string} [column='*']\n   *   Specify a column to count - rows with null values in this column will be excluded.\n   * @param {Object=} options\n   *   Hash of options.\n   * @returns {Promise<Number>}\n   *   A promise resolving to the number of matching rows.\n   */\n  count: _promise2.default.method(function (column, options) {\n    if (!(0, _lodash.isString)(column)) {\n      options = column;\n      column = undefined;\n    }\n    if (options) options = (0, _lodash.clone)(options);\n    return this.sync(options).count(column);\n  }),\n\n  /**\n   * @method Collection#fetchOne\n   * @description\n   *\n   * Fetch and return a single {@link Model model} from the collection,\n   * maintaining any {@link Relation relation} data from the collection, and\n   * any {@link Collection#query query} parameters that have already been passed\n   * to the collection. Especially helpful on relations, where you would only\n   * like to return a single model from the associated collection.\n   *\n   * @example\n   *\n   * // select * from authors where site_id = 1 and id = 2 limit 1;\n   * new Site({id:1})\n   *   .authors()\n   *   .query({where: {id: 2}})\n   *   .fetchOne()\n   *   .then(function(model) {\n   *     // ...\n   *   });\n   *\n   * @param {Object=}  options\n   * @param {boolean} [options.require=false]\n   *   If `true`, will reject the returned response with a {@link\n   *   Model.NotFoundError NotFoundError} if no result is found.\n   * @param {(string|string[])} [options.columns='*']\n   *   Limit the number of columns fetched.\n   * @param {Transaction} options.transacting\n   *  Optionally run the query in a transaction.\n   *\n   * @throws {Model.NotFoundError}\n   * @returns {Promise<Model|null>}\n   *  A promise resolving to the fetched {@link Model model} or `null` if none exists.\n   */\n  fetchOne: _promise2.default.method(function (options) {\n    var model = new this.model();\n    model._knex = this.query().clone();\n    this.resetQuery();\n    if (this.relatedData) model.relatedData = this.relatedData;\n    return model.fetch(options);\n  }),\n\n  /**\n   * @method Collection#load\n   * @description\n   * `load` is used to eager load relations onto a Collection, in a similar way\n   * that the `withRelated` property works on {@link Collection#fetch fetch}.\n   * Nested eager loads can be specified by separating the nested relations with\n   * `'.'`.\n   *\n   *  @param {string|string[]} relations The relation, or relations, to be loaded.\n   *  @param {Object=}      options Hash of options.\n   *  @param {Transaction=} options.transacting\n   *\n   *  @returns {Promise<Collection>} A promise resolving to this {@link\n   *  Collection collection}\n   */\n  load: _promise2.default.method(function (relations, options) {\n    if (!(0, _lodash.isArray)(relations)) relations = [relations];\n    options = (0, _lodash.extend)({}, options, { shallow: true, withRelated: relations });\n    return new _eager2.default(this.models, this.toJSON(options), new this.model()).fetch(options).return(this);\n  }),\n\n  /**\n   * @method Collection#create\n   * @description\n   *\n   * Convenience method to create a new {@link Model model} instance within a\n   * collection. Equivalent to instantiating a model with a hash of {@link\n   * Model#attributes attributes}, {@link Model#save saving} the model to the\n   * database then adding the model to the collection.\n   *\n   * When used on a relation, `create` will automatically set foreign key\n   * attributes before persisting the `Model`.\n   *\n   * ```\n   * const { courses, ...attributes } = req.body;\n   *\n   * Student.forge(attributes).save().tap(student =>\n   *   Promise.map(courses, course => student.related('courses').create(course))\n   * ).then(student =>\n   *   res.status(200).send(student)\n   * ).catch(error =>\n   *   res.status(500).send(error.message)\n   * );\n   * ```\n   *\n   * @param {Object} model A set of attributes to be set on the new model.\n   * @param {Object=} options\n   * @param {Transaction=} options.transacting\n   *\n   * @returns {Promise<Model>} A promise resolving with the new {@link Modle\n   * model}.\n   */\n  create: _promise2.default.method(function (model, options) {\n    options = options != null ? (0, _lodash.clone)(options) : {};\n    var relatedData = this.relatedData;\n\n    model = this._prepareModel(model, options);\n\n    // If we've already added things on the query chain,\n    // these are likely intended for the model.\n    if (this._knex) {\n      model._knex = this._knex;\n      this.resetQuery();\n    }\n    return _helpers2.default.saveConstraints(model, relatedData).save(null, options).bind(this).then(function () {\n      if (relatedData && relatedData.type === 'belongsToMany') {\n        return this.attach(model, (0, _lodash.omit)(options, 'query'));\n      }\n    }).then(function () {\n      this.add(model, options);\n    }).return(model);\n  }),\n\n  /**\n   * @method Collection#resetQuery\n   * @description\n   * Used to reset the internal state of the current query builder instance.\n   * This method is called internally each time a database action is completed\n   * by {@link Sync}.\n   *\n   * @returns {Collection} Self, this method is chainable.\n   */\n  resetQuery: function resetQuery() {\n    this._knex = null;\n    return this;\n  },\n\n  /**\n   * @method Collection#query\n   * @description\n   *\n   * `query` is used to tap into the underlying Knex query builder instance for\n   * the current collection. If called with no arguments, it will return the\n   * query builder directly. Otherwise, it will call the specified `method` on\n   * the query builder, applying any additional arguments from the\n   * `collection.query` call. If the `method` argument is a function, it will be\n   * called with the Knex query builder as the context and the first argument.\n   *\n   * @example\n   *\n   * let qb = collection.query();\n   *     qb.where({id: 1}).select().then(function(resp) {\n   *       // ...\n   *     });\n   *\n   * collection.query(function(qb) {\n   *   qb.where('id', '>', 5).andWhere('first_name', '=', 'Test');\n   * }).fetch()\n   *   .then(function(collection) {\n   *     // ...\n   *   });\n   *\n   * collection\n   *   .query('where', 'other_id', '=', '5')\n   *   .fetch()\n   *   .then(function(collection) {\n   *     // ...\n   *   });\n   *\n   * @param {function|Object|...string=} arguments The query method.\n   * @returns {Collection|QueryBuilder}\n   *   Will return this model or, if called with no arguments, the underlying query builder.\n   *\n   * @see {@link http://knexjs.org/#Builder Knex `QueryBuilder`}\n   */\n  query: function query() {\n    return _helpers2.default.query(this, (0, _lodash.toArray)(arguments));\n  },\n\n  /**\n   * @method Collection#orderBy\n   * @since 0.9.3\n   * @description\n   *\n   * Specifies the column to sort on and sort order.\n   *\n   * The order parameter is optional, and defaults to 'ASC'. You may\n   * also specify 'DESC' order by prepending a hyphen to the sort column\n   * name. `orderBy(\"date\", 'DESC')` is the same as `orderBy(\"-date\")`.\n   *\n   * Unless specified using dot notation (i.e., \"table.column\"), the default\n   * table will be the table name of the model `orderBy` was called on.\n   *\n   * @example\n   *\n   * Cars.forge().orderBy('color', 'ASC').fetch()\n   *    .then(function (rows) { // ...\n   *\n   * @param sort {string}\n   *   Column to sort on\n   * @param order {string}\n   *   Ascending ('ASC') or descending ('DESC') order\n   */\n  orderBy: function orderBy() {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _helpers2.default.orderBy.apply(_helpers2.default, [this].concat(args));\n  },\n\n\n  /**\n   * @method Collection#query\n   * @private\n   * @description Creates and returns a new `Bookshelf.Sync` instance.\n   */\n  sync: function sync(options) {\n    return new _sync2.default(this, options);\n  },\n\n  /* Ensure that QueryBuilder is copied on clone. */\n  clone: function clone() {\n    var cloned = BookshelfCollection.__super__.clone.apply(this, arguments);\n    if (this._knex != null) {\n      cloned._knex = cloned._builder(this._knex.clone());\n    }\n    return cloned;\n  },\n\n\n  /**\n   * @method Collection#_handleResponse\n   * @private\n   * @description\n   * Handles the response data for the collection, returning from the\n   * collection's `fetch` call.\n   */\n  _handleResponse: function _handleResponse(response) {\n    var relatedData = this.relatedData;\n\n    this.set(response, { silent: true, parse: true }).invokeMap('_reset');\n    if (relatedData && relatedData.isJoined()) {\n      relatedData.parsePivot(this.models);\n    }\n  },\n\n  /**\n   * @method Collection#_handleEager\n   * @private\n   * @description\n   * Handle the related data loading on the collection.\n   */\n  _handleEager: function _handleEager(response, options) {\n    return new _eager2.default(this.models, response, new this.model()).fetch(options);\n  }\n\n}, {\n\n  extended: function extended(child) {\n    /**\n     * @class Collection.EmptyError\n     * @description\n     *   Thrown when no records are found by {@link Collection#fetch fetch},\n     *   {@link Model#fetchAll}, or {@link Model.fetchAll} when called with\n     *   the `{require: true}` option.\n     */\n    child.EmptyError = (0, _createError2.default)(this.EmptyError);\n  }\n\n});\n\nBookshelfCollection.EmptyError = _errors2.default.EmptyError;\n\nexports.default = BookshelfCollection;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/base/collection.js":"'use strict';\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _inherits = require('inherits');\n\nvar _inherits2 = _interopRequireDefault(_inherits);\n\nvar _events = require('./events');\n\nvar _events2 = _interopRequireDefault(_events);\n\nvar _promise = require('./promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _model = require('./model');\n\nvar _model2 = _interopRequireDefault(_model);\n\nvar _extend = require('../extend');\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// All components that need to be referenced in this scope.\n// Base Collection\n// ---------------\n\n// All exernal dependencies required in this scope.\nvar _Array$prototype = Array.prototype,\n    splice = _Array$prototype.splice,\n    slice = _Array$prototype.slice;\n\n/**\n * @class CollectionBase\n * @extends Events\n * @inheritdoc\n */\n\nfunction CollectionBase(models, options) {\n  if (options) _lodash2.default.extend(this, _lodash2.default.pick(options, collectionProps));\n  this._reset();\n  this.initialize.apply(this, arguments);\n  if (!_lodash2.default.isFunction(this.model)) {\n    throw new Error('A valid `model` constructor must be defined for all collections.');\n  }\n  if (models) this.reset(models, _lodash2.default.extend({ silent: true }, options));\n}\n\n/**\n * @method CollectionBase#on\n * @example\n *\n * const ships = new bookshelf.Collection;\n * ships.on('fetched', function(collection, response) {\n *   // Do something after the data has been fetched from the database\n * })\n *\n * @see Events#on\n */\n\n/**\n * @method CollectionBase#off\n * @example\n *\n * ships.off('fetched') // Remove the 'fetched' event listener\n *\n * @see Events#off\n */\n\n/**\n * @method CollectionBase#trigger\n * @example\n *\n * ships.trigger('fetched')\n *\n * @see Events#trigger\n */\n(0, _inherits2.default)(CollectionBase, _events2.default);\n\n// List of attributes attached directly from the constructor's options object.\n//\n// RE: 'relatedData'\n// It's okay for two `Collection`s to share a `Relation` instance.\n// `relatedData` does not mutate itself after declaration. This is only\n// here because `clone` needs to duplicate this property. It should not\n// be documented as a valid argument for consumer code.\n//\n// RE: 'attach', 'detach', 'updatePivot', 'withPivot', '_processPivot', '_processPlainPivot', '_processModelPivot'\n// It's okay to whitelist also given method references to be copied when cloning\n// a collection. These methods are present only when `relatedData` is present and\n// its `type` is 'belongsToMany'. So it is safe to put them in the list and use them\n// without any additional verification.\n// These should not be documented as a valid arguments for consumer code.\nvar collectionProps = ['model', 'comparator', 'relatedData',\n// `belongsToMany` pivotal collection properties\n'attach', 'detach', 'updatePivot', 'withPivot', '_processPivot', '_processPlainPivot', '_processModelPivot'];\n\n// Copied over from Backbone.\nvar setOptions = { add: true, remove: true, merge: true };\nvar addOptions = { add: true, remove: false };\n\n/**\n * @method CollectionBase#initialize\n * @description\n * Custom initialization function.\n * @see Collection\n */\nCollectionBase.prototype.initialize = _lodash.noop;\n\n/**\n * @method\n * @private\n * @description\n * The `tableName` on the associated Model, used in relation building.\n * @returns {string} The {@link Model#tableName tableName} of the associated model.\n */\nCollectionBase.prototype.tableName = function () {\n  return _lodash2.default.result(this.model.prototype, 'tableName');\n};\n\n/**\n * @method\n * @private\n * @description\n * The `idAttribute` on the associated Model, used in relation building.\n * @returns {string} The {@link Model#idAttribute idAttribute} of the associated model.\n */\nCollectionBase.prototype.idAttribute = function () {\n  return this.model.prototype.idAttribute;\n};\n\nCollectionBase.prototype.toString = function () {\n  return '[Object Collection]';\n};\n\n/**\n * @method\n * @description\n *\n * Return a raw array of the collection's {@link Model#attributes\n * attributes} for JSON stringification. If the {@link Model models} have any\n * relations defined, this will also call {@link Model#toJSON toJSON} on\n * each of the related objects, and include them on the object unless\n * `{shallow: true}` is passed as an option.\n *\n * `serialize` is called internally by {@link Collection#toJSON toJSON}.\n * Override this function if you want to customize its output.\n*\n * @param {Object=} options\n * @param {bool}    [options.shallow=false]   Exclude relations.\n * @param {bool}    [options.omitPivot=false] Exclude pivot values.\n * @param {bool}    [options.omitNew=false]   Exclude models that return true for isNew.\n * @returns {Object} Serialized model as a plain object.\n */\nCollectionBase.prototype.serialize = function (options) {\n  return (0, _lodash.invokeMap)(this.models, 'toJSON', options).filter((0, _lodash.negate)(_lodash.isNull));\n};\n\n/**\n * @method\n * @description\n *\n * Called automatically by {@link\n * https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#toJSON()_behavior\n * `JSON.stringify`}. To customize serialization, override {@link\n * Collection#serialize serialize}.\n *\n * @param {options} Options passed to {@link Collection#serialize}.\n */\nCollectionBase.prototype.toJSON = function (options) {\n  return this.serialize(options);\n};\n\n/**\n * @method\n * @description\n *\n * The set method performs a \"smart\" update of the collection with the passed\n * model or list of models. If a model in the list isn't yet in the\n * collection it will be added; if the model is already in the collection\n * its attributes will be merged; and if the collection contains any models\n * that aren't present in the list, they'll be removed. If you'd like to\n * customize the behavior, you can disable it with options: `{add: false}`,\n * `{remove: false}`, or `{merge: false}`.\n *\n * @example\n *\n * var vanHalen = new bookshelf.Collection([eddie, alex, stone, roth]);\n * vanHalen.set([eddie, alex, stone, hagar]);\n *\n * @param {Object[]|Model[]|Object|Model} models One or more models or raw\n * attribute objects.\n * @param {Object=} options See description.\n * @returns {Collection} Self, this method is chainable.\n */\nCollectionBase.prototype.set = function (models, options) {\n  options = _lodash2.default.defaults({}, options, setOptions);\n  if (!_lodash2.default.isArray(models)) models = models ? [models] : [];\n  if (options.parse) models = this.parse(models, options);\n  var i = void 0,\n      l = void 0,\n      id = void 0,\n      model = void 0,\n      attrs = void 0;\n  var at = options.at;\n  var targetModel = this.model;\n  var toAdd = [];\n  var toRemove = [];\n  var modelMap = {};\n  var _options = options,\n      add = _options.add,\n      merge = _options.merge,\n      remove = _options.remove;\n\n  var order = add && remove ? [] : false;\n\n  // Turn bare objects into model references, and prevent invalid models\n  // from being added.\n  for (i = 0, l = models.length; i < l; i++) {\n    attrs = models[i];\n    if (attrs instanceof _model2.default) {\n      id = model = attrs;\n    } else {\n      id = attrs[targetModel.prototype.idAttribute];\n    }\n\n    // If a duplicate is found, prevent it from being added and\n    // optionally merge it into the existing model.\n    var existing = this.get(id);\n    if (existing) {\n      if (remove) {\n        modelMap[existing.cid] = true;\n      }\n      if (merge) {\n        attrs = attrs === model ? model.attributes : attrs;\n        if (options.parse) attrs = existing.parse(attrs, options);\n        existing.set(attrs, options);\n      }\n\n      // This is a new model, push it to the `toAdd` list.\n    } else if (add) {\n      if (!(model = this._prepareModel(attrs, options))) continue;\n      toAdd.push(model);\n      this._byId[model.cid] = model;\n      if (model.id != null) this._byId[model.id] = model;\n    }\n    if (order) order.push(existing || model);\n  }\n\n  // Remove nonexistent models if appropriate.\n  if (remove) {\n    for (i = 0, l = this.length; i < l; ++i) {\n      if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);\n    }\n    if (toRemove.length) this.remove(toRemove, options);\n  }\n\n  // See if sorting is needed, update `length` and splice in new models.\n  if (toAdd.length || order && order.length) {\n    this.length += toAdd.length;\n    if (at != null) {\n      splice.apply(this.models, [at, 0].concat(toAdd));\n    } else {\n      if (order) {\n        this.models.length = 0;\n      } else {\n        order = toAdd;\n      }\n      for (i = 0, l = order.length; i < l; ++i) {\n        this.models.push(order[i]);\n      }\n    }\n  }\n\n  if (options.silent) return this;\n\n  // Trigger `add` events.\n  for (i = 0, l = toAdd.length; i < l; i++) {\n    (model = toAdd[i]).trigger('add', model, this, options);\n  }\n  return this;\n};\n\n/**\n * @method\n * @private\n * @description\n * Prepare a model or hash of attributes to be added to this collection.\n */\nCollectionBase.prototype._prepareModel = function (attrs, options) {\n  if (attrs instanceof _model2.default) return attrs;\n  return new this.model(attrs, options);\n};\n\n/**\n * @method\n * @private\n * @description\n * Run \"Promise.map\" over the models\n */\nCollectionBase.prototype.mapThen = function (iterator, context) {\n  return _promise2.default.bind(context).thenReturn(this.models).map(iterator);\n};\n\n/**\n * @method\n * @description\n * Shortcut for calling `Promise.all` around a {@link Collection#invoke}, this\n * will delegate to the collection's `invoke` method, resolving the promise with\n * an array of responses all async (and sync) behavior has settled. Useful for\n * bulk saving or deleting models:\n *\n *     collection.invokeThen('save', null, options).then(function() {\n *       // ... all models in the collection have been saved\n *     });\n *\n *     collection.invokeThen('destroy', options).then(function() {\n *       // ... all models in the collection have been destroyed\n *     });\n *\n * @param {string} method The {@link Model model} method to invoke.\n * @param {...mixed} arguments Arguments to `method`.\n * @returns {Promise<mixed[]>}\n *   Promise resolving to array of results from invocation.\n */\nCollectionBase.prototype.invokeThen = function () {\n  return _promise2.default.all(this.invokeMap.apply(this, arguments));\n};\n\n/**\n * @method\n * @description\n * Run \"reduce\" over the models in the collection.\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce | MDN `Array.prototype.reduce` reference.}\n * @param {Function} iterator\n * @param {mixed} initialValue\n * @param {Object} context Bound to `this` in the `iterator` callback.\n * @returns {Promise<mixed[]>}\n *   Promise resolving to array of results from invocation.\n *\n */\nCollectionBase.prototype.reduceThen = function (iterator, initialValue, context) {\n  return _promise2.default.bind(context).thenReturn(this.models).reduce(iterator, initialValue).bind();\n};\n\nCollectionBase.prototype.fetch = function () {\n  return _promise2.default.rejected('The fetch method has not been implemented');\n};\n\n/**\n * @method\n * @description\n *\n * Add a {@link Model model} (or an array of models) to the collection, You may\n * also pass raw attributes objects, and have them be vivified as instances of\n * the model. Pass `{at: index}` to splice the model into the collection at the\n * specified `index`. If you're adding models to the collection that are already\n * in the collection, they'll be ignored, unless you pass `{merge: true}`, in\n * which case their {@link Model#attributes attributes} will be merged into the\n * corresponding models.\n *\n * *Note that adding the same model (a model with the same id) to a collection\n * more than once is a no-op.*\n *\n * @example\n *\n * const ships = new bookshelf.Collection;\n *\n * ships.add([\n *   {name: \"Flying Dutchman\"},\n *   {name: \"Black Pearl\"}\n * ]);\n *\n * @param {Object[]|Model[]|Object|Model} models One or more models or raw\n * attribute objects.\n * @param {Object=} options See description.\n * @returns {Collection} Self, this method is chainable.\n */\nCollectionBase.prototype.add = function (models, options) {\n  return this.set(models, _lodash2.default.extend({ merge: false }, options, addOptions));\n};\n\n/**\n * @method\n * @description\n *\n * Remove a {@link Model model} (or an array of models) from the collection,\n * but does not remove the model from the database, use the model's {@link\n * Model#destroy destroy} method for this.\n *\n * @param {Model|Model[]} models The model, or models, to be removed.\n * @param {Object} options\n * @returns {Model|Model[]} The same value passed as `models` argument.\n */\nCollectionBase.prototype.remove = function (models, options) {\n  var singular = !_lodash2.default.isArray(models);\n  models = singular ? [models] : _lodash2.default.clone(models);\n  options = options || {};\n  for (var i = 0; i < models.length; i++) {\n    var model = models[i] = this.get(models[i]);\n    if (!model) continue;\n    delete this._byId[model.id];\n    delete this._byId[model.cid];\n    var index = this.indexOf(model);\n    this.models.splice(index, 1);\n    this.length = this.length - 1;\n    if (!options.silent) {\n      options.index = index;\n      model.trigger('remove', model, this, options);\n    }\n  }\n  return singular ? models[0] : models;\n};\n\n/**\n * @method\n * @description\n *\n * Adding and removing models one at a time is all well and good, but sometimes\n * you have so many models to change that you'd rather just update the\n * collection in bulk. Use `reset` to replace a collection with a new list of\n * models (or attribute hashes). Calling `collection.reset()` without passing\n * any models as arguments will empty the entire collection.\n *\n * @param {Object[]|Model[]|Object|Model} models One or more models or raw\n * attribute objects.\n * @param {Object} options See {@link Collection#add add}.\n * @returns {Model[]} Array of models.\n */\nCollectionBase.prototype.reset = function (models, options) {\n  options = options || {};\n  options.previousModels = this.models;\n  this._reset();\n  models = this.add(models, _lodash2.default.extend({ silent: true }, options));\n  if (!options.silent) this.trigger('reset', this, options);\n  return models;\n};\n\n/**\n * @method\n * @description\n * Add a model to the end of the collection.\n * @param {Object[]|Model[]|Object|Model} model One or more models or raw\n * attribute objects.\n * @returns {Collection} Self, this method is chainable.\n */\nCollectionBase.prototype.push = function (model, options) {\n  return this.add(model, _lodash2.default.extend({ at: this.length }, options));\n};\n\n/**\n * @method\n * @description\n * Remove a model from the end of the collection.\n */\nCollectionBase.prototype.pop = function (options) {\n  var model = this.at(this.length - 1);\n  this.remove(model, options);\n  return model;\n};\n\n/**\n * @method\n * @description\n * Add a model to the beginning of the collection.\n */\nCollectionBase.prototype.unshift = function (model, options) {\n  return this.add(model, _lodash2.default.extend({ at: 0 }, options));\n};\n\n/**\n * @method\n * @description\n * Remove a model from the beginning of the collection.\n */\nCollectionBase.prototype.shift = function (options) {\n  var model = this.at(0);\n  this.remove(model, options);\n  return model;\n};\n\n/**\n * @method\n * @description\n * Slice out a sub-array of models from the collection.\n */\nCollectionBase.prototype.slice = function () {\n  return slice.apply(this.models, arguments);\n};\n\n/**\n * @method\n * @description\n *\n * Get a model from a collection, specified by an {@link Model#id id}, a {@link\n * Model#cid cid}, or by passing in a {@link Model model}.\n *\n * @example\n *\n * const book = library.get(110);\n *\n * @returns {Model} The model, or `undefined` if it is not in the collection.\n */\nCollectionBase.prototype.get = function (obj) {\n  if (obj == null) return void 0;\n  return this._byId[obj.id] || this._byId[obj.cid] || this._byId[obj];\n};\n\n/**\n * @method\n * @description\n * Get a model from a collection, specified by index. Useful if your collection\n * is sorted, and if your collection isn't sorted, `at` will still retrieve\n * models in insertion order.\n */\nCollectionBase.prototype.at = function (index) {\n  return this.models[index];\n};\n\n/**\n * @method\n * @description\n * Return models with matching attributes. Useful for simple cases of `filter`.\n * @returns {Model[]} Array of matching models.\n */\nCollectionBase.prototype.where = function (attrs, first) {\n  if (_lodash2.default.isEmpty(attrs)) return first ? void 0 : [];\n  return this[first ? 'find' : 'filter'](function (model) {\n    for (var key in attrs) {\n      if (attrs[key] !== model.get(key)) return false;\n    }\n    return true;\n  });\n};\n\n/**\n * @method\n * @description\n * Return the first model with matching attributes. Useful for simple cases of\n * `find`.\n * @returns {Model} The first matching model.\n */\nCollectionBase.prototype.findWhere = function (attrs) {\n  return this.where(attrs, true);\n};\n\n/**\n * @method\n * @private\n * @description\n * Force the collection to re-sort itself, based on a comporator defined on the model.\n */\nCollectionBase.prototype.sort = function (options) {\n  if (!this.comparator) throw new Error('Cannot sort a set without a comparator');\n  options = options || {};\n\n  // Run sort based on type of `comparator`.\n  if (_lodash2.default.isString(this.comparator) || this.comparator.length === 1) {\n    this.models = this.sortBy(this.comparator, this);\n  } else {\n    this.models.sort(_lodash2.default.bind(this.comparator, this));\n  }\n\n  if (!options.silent) this.trigger('sort', this, options);\n  return this;\n};\n\n/**\n * @method\n * @description\n * Pluck an attribute from each model in the collection.\n * @returns {mixed[]} An array of attribute values.\n */\nCollectionBase.prototype.pluck = function (attr) {\n  return this.invokeMap('get', attr);\n};\n\n/**\n * @method\n * @description\n * The `parse` method is called whenever a collection's data is returned in a\n * {@link Collection#fetch fetch} call. The function is passed the raw\n * database `response` array, and should return an array to be set on the\n * collection. The default implementation is a no-op, simply passing through\n * the JSON response.\n *\n * @param {Object[]} resp Raw database response array.\n */\nCollectionBase.prototype.parse = function (resp) {\n  return resp;\n};\n\n/**\n * @method\n * @description\n * Create a new collection with an identical list of models as this one.\n */\nCollectionBase.prototype.clone = function () {\n  return new this.constructor(this.models, _lodash2.default.pick(this, collectionProps));\n};\n\n/**\n * @method\n * @private\n * @description\n * Reset all internal state. Called when the collection is first initialized or reset.\n */\nCollectionBase.prototype._reset = function () {\n  this.length = 0;\n  this.models = [];\n  this._byId = Object.create(null);\n};\n\n/**\n * @method CollectionBase#forEach\n * @see http://lodash.com/docs/#forEach\n */\n/**\n * @method CollectionBase#each\n * @see http://lodash.com/docs/#each\n */\n/**\n * @method CollectionBase#map\n * @see http://lodash.com/docs/#map\n */\n/**\n * @method CollectionBase#reduce\n * @see http://lodash.com/docs/#reduce\n */\n/**\n * @method CollectionBase#reduceRight\n * @see http://lodash.com/docs/#reduceRight\n */\n/**\n * @method CollectionBase#find\n * @see http://lodash.com/docs/#find\n */\n/**\n * @method CollectionBase#filter\n * @see http://lodash.com/docs/#filter\n */\n/**\n * @method CollectionBase#reject\n * @see http://lodash.com/docs/#reject\n */\n/**\n * @method CollectionBase#every\n * @see http://lodash.com/docs/#every\n */\n/**\n * @method CollectionBase#some\n * @see http://lodash.com/docs/#some\n */\n/**\n * @method CollectionBase#includes\n * @see http://lodash.com/docs/#includes\n */\n/**\n * @method CollectionBase#invokeMap\n * @see http://lodash.com/docs/#invokeMap\n */\n/**\n * @method CollectionBase#max\n * @see http://lodash.com/docs/#max\n */\n/**\n * @method CollectionBase#maxBy\n * @see http://lodash.com/docs/#maxBy\n */\n/**\n * @method CollectionBase#min\n * @see http://lodash.com/docs/#min\n */\n/**\n * @method CollectionBase#minBy\n * @see http://lodash.com/docs/#minBy\n */\n/**\n * @method CollectionBase#toArray\n * @see http://lodash.com/docs/#toArray\n */\n/**\n * @method CollectionBase#size\n * @see http://lodash.com/docs/#size\n */\n/**\n * @method CollectionBase#first\n * @see http://lodash.com/docs/#first\n */\n/**\n * @method CollectionBase#head\n * @see http://lodash.com/docs/#head\n */\n/**\n * @method CollectionBase#take\n * @see http://lodash.com/docs/#take\n */\n/**\n * @method CollectionBase#initial\n * @see http://lodash.com/docs/#initial\n */\n/**\n * @method CollectionBase#tail\n * @see http://lodash.com/docs/#tail\n */\n/**\n * @method CollectionBase#drop\n * @see http://lodash.com/docs/#drop\n */\n/**\n * @method CollectionBase#last\n * @see http://lodash.com/docs/#last\n */\n/**\n * @method CollectionBase#without\n * @see http://lodash.com/docs/#without\n */\n/**\n * @method CollectionBase#difference\n * @see http://lodash.com/docs/#difference\n */\n/**\n * @method CollectionBase#indexOf\n * @see http://lodash.com/docs/#indexOf\n */\n/**\n * @method CollectionBase#shuffle\n * @see http://lodash.com/docs/#shuffle\n */\n/**\n * @method CollectionBase#lastIndexOf\n * @see http://lodash.com/docs/#lastIndexOf\n */\n/**\n * @method CollectionBase#isEmpty\n * @see http://lodash.com/docs/#isEmpty\n */\n/**\n * @method CollectionBase#chain\n * @see http://lodash.com/docs/#chain\n */\n// Lodash methods that we want to implement on the Collection.\n// 90% of the core usefulness of Backbone Collections is actually implemented\n// right here:\nvar methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find', 'filter', 'every', 'some', 'includes', 'invokeMap', 'max', 'min', 'maxBy', 'minBy', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle', 'lastIndexOf', 'isEmpty', 'chain'];\n\n// Mix in each Lodash method as a proxy to `Collection#models`.\n_lodash2.default.each(methods, function (method) {\n  CollectionBase.prototype[method] = function () {\n    return _lodash2.default[method].apply(_lodash2.default, [this.models].concat(Array.prototype.slice.call(arguments)));\n  };\n});\n\n/**\n * @method CollectionBase#groupBy\n * @see http://lodash.com/docs/#groupBy\n */\n// Underscore methods that we want to implement on the Collection.\n/**\n * @method CollectionBase#countBy\n * @see http://lodash.com/docs/#countBy\n */\n// Underscore methods that we want to implement on the Collection.\n/**\n * @method CollectionBase#sortBy\n * @see http://lodash.com/docs/#sortBy\n */\n// Lodash methods that take a property name as an argument.\nvar attributeMethods = ['groupBy', 'countBy', 'sortBy'];\n\n// Use attributes instead of properties.\n_lodash2.default.each(attributeMethods, function (method) {\n  CollectionBase.prototype[method] = function (value, context) {\n    var iterator = _lodash2.default.isFunction(value) ? value : function (model) {\n      return model.get(value);\n    };\n    return _lodash2.default[method](this.models, _lodash2.default.bind(iterator, context));\n  };\n});\n\n/**\n * @method Collection.extend\n * @description\n *\n * To create a {@link Collection} class of your own, extend\n * `Bookshelf.Collection`.\n *\n * @param {Object=} prototypeProperties\n *   Instance methods and properties to be attached to instances of the new\n *   class.\n * @param {Object=} classProperties\n *   Class (ie. static) functions and properties to be attached to the\n *   constructor of the new class.\n * @returns {Function} Constructor for new `Collection` subclass.\n */\nCollectionBase.extend = _extend2.default;\n\n/*\n * NOTE: For some reason `export` is failing in the version of Babel I'm\n * currently using. At some stage it should be corrected to:\n *\n *     export default CollectionBase;\n */\nmodule.exports = CollectionBase;","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/relation.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _inflection = require('inflection');\n\nvar _inflection2 = _interopRequireDefault(_inflection);\n\nvar _helpers = require('./helpers');\n\nvar _helpers2 = _interopRequireDefault(_helpers);\n\nvar _model = require('./base/model');\n\nvar _model2 = _interopRequireDefault(_model);\n\nvar _relation = require('./base/relation');\n\nvar _relation2 = _interopRequireDefault(_relation);\n\nvar _promise = require('./base/promise');\n\nvar _promise2 = _interopRequireDefault(_promise);\n\nvar _constants = require('./constants');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar push = Array.prototype.push; // Relation\n// ---------------\n\nvar removePivotPrefix = function removePivotPrefix(key) {\n  return key.slice(_constants.PIVOT_PREFIX.length);\n};\nvar hasPivotPrefix = function hasPivotPrefix(key) {\n  return _lodash2.default.startsWith(key, _constants.PIVOT_PREFIX);\n};\n\nexports.default = _relation2.default.extend({\n\n  // Assembles the new model or collection we're creating an instance of,\n  // gathering any relevant primitives from the parent object,\n  // without keeping any hard references.\n  init: function init(parent) {\n    this.parentId = parent.id;\n    this.parentTableName = _lodash2.default.result(parent, 'tableName');\n    this.parentIdAttribute = this.attribute('parentIdAttribute', parent);\n\n    // Use formatted attributes so that morphKey and foreignKey will match\n    // attribute keys.\n    this.parentAttributes = parent.format(_lodash2.default.clone(parent.attributes));\n\n    if (this.type === 'morphTo' && !parent._isEager) {\n      // If the parent object is eager loading, and it's a polymorphic `morphTo` relation,\n      // we can't know what the target will be until the models are sorted and matched.\n      this.target = _helpers2.default.morphCandidate(this.candidates, this.parentAttributes[this.key('morphKey')]);\n      this.targetTableName = _lodash2.default.result(this.target.prototype, 'tableName');\n    }\n\n    this.targetIdAttribute = this.attribute('targetIdAttribute', parent);\n    this.parentFk = this.attribute('parentFk');\n\n    var target = this.target ? this.relatedInstance() : {};\n    target.relatedData = this;\n\n    if (this.type === 'belongsToMany') {\n      _lodash2.default.extend(target, pivotHelpers);\n    }\n\n    return target;\n  },\n\n  // Initializes a `through` relation, setting the `Target` model and `options`,\n  // which includes any additional keys for the relation.\n  through: function through(source, Target, options) {\n    var type = this.type;\n    if (type !== 'hasOne' && type !== 'hasMany' && type !== 'belongsToMany' && type !== 'belongsTo') {\n      throw new Error('`through` is only chainable from `hasOne`, `belongsTo`, `hasMany`, or `belongsToMany`');\n    }\n\n    this.throughTarget = Target;\n    this.throughTableName = _lodash2.default.result(Target.prototype, 'tableName');\n\n    _lodash2.default.extend(this, options);\n    _lodash2.default.extend(source, pivotHelpers);\n\n    this.parentIdAttribute = this.attribute('parentIdAttribute');\n    this.targetIdAttribute = this.attribute('targetIdAttribute');\n    this.throughIdAttribute = this.attribute('throughIdAttribute', Target);\n    this.parentFk = this.attribute('parentFk');\n\n    // Set the appropriate foreign key if we're doing a belongsToMany, for convenience.\n    if (this.type === 'belongsToMany') {\n      this.foreignKey = this.throughForeignKey;\n    } else if (this.otherKey) {\n      this.foreignKey = this.otherKey;\n    }\n\n    return source;\n  },\n\n  // Generates and returns a specified key, for convenience... one of\n  // `foreignKey`, `otherKey`, `throughForeignKey`.\n  key: function key(keyName) {\n    if (this[keyName]) return this[keyName];\n    switch (keyName) {\n      case 'otherKey':\n        this[keyName] = singularMemo(this.targetTableName) + '_' + this.targetIdAttribute;\n        break;\n      case 'throughForeignKey':\n        this[keyName] = singularMemo(this.joinTable()) + '_' + this.throughIdAttribute;\n        break;\n      case 'foreignKey':\n        switch (this.type) {\n          case 'morphTo':\n            {\n              var idKeyName = this.columnNames && this.columnNames[1] ? this.columnNames[1] : this.morphName + '_id';\n              this[keyName] = idKeyName;\n              break;\n            }\n          case 'belongsTo':\n            this[keyName] = singularMemo(this.targetTableName) + '_' + this.targetIdAttribute;\n            break;\n          default:\n            if (this.isMorph()) {\n              this[keyName] = this.columnNames && this.columnNames[1] ? this.columnNames[1] : this.morphName + '_id';\n              break;\n            }\n            this[keyName] = singularMemo(this.parentTableName) + '_' + this.parentIdAttribute;\n            break;\n        }\n        break;\n      case 'morphKey':\n        this[keyName] = this.columnNames && this.columnNames[0] ? this.columnNames[0] : this.morphName + '_type';\n        break;\n      case 'morphValue':\n        this[keyName] = this.parentTableName || this.targetTableName;\n        break;\n    }\n    return this[keyName];\n  },\n\n  // Get the correct value for the following attributes:\n  // parentIdAttribute, targetIdAttribute, throughIdAttribute and parentFk.\n  attribute: function attribute(_attribute, parent) {\n    switch (_attribute) {\n      case 'parentIdAttribute':\n        if (this.isThrough()) {\n          if (this.type === 'belongsTo' && this.throughForeignKey) {\n            return this.throughForeignKey;\n          }\n\n          if (this.type === 'belongsToMany' && this.isThroughForeignKeyTargeted()) {\n            return this.throughForeignKeyTarget;\n          }\n\n          if (this.isOtherKeyTargeted()) {\n            return this.otherKeyTarget;\n          }\n\n          // Return attribute calculated on `init` by default.\n          return this.parentIdAttribute;\n        }\n\n        if (this.isForeignKeyTargeted()) {\n          return this.foreignKeyTarget;\n        }\n\n        return _lodash2.default.result(parent, 'idAttribute');\n\n      case 'targetIdAttribute':\n        if (this.isThrough()) {\n          if ((this.type === 'belongsToMany' || this.type === 'belongsTo') && this.isOtherKeyTargeted()) {\n            return this.otherKeyTarget;\n          }\n\n          // Return attribute calculated on `init` by default.\n          return this.targetIdAttribute;\n        }\n\n        if (this.type === 'morphTo' && !parent._isEager) {\n          return _lodash2.default.result(this.target.prototype, 'idAttribute');\n        }\n\n        if (this.type === 'belongsTo' && this.isForeignKeyTargeted()) {\n          return this.foreignKeyTarget;\n        }\n\n        if (this.type === 'belongsToMany' && this.isOtherKeyTargeted()) {\n          return this.otherKeyTarget;\n        }\n\n        return this.targetIdAttribute;\n\n      case 'throughIdAttribute':\n        if (this.type !== 'belongsToMany' && this.isThroughForeignKeyTargeted()) {\n          return this.throughForeignKeyTarget;\n        }\n\n        if (this.type === 'belongsToMany' && this.throughForeignKey) {\n          return this.throughForeignKey;\n        }\n\n        return _lodash2.default.result(parent.prototype, 'idAttribute');\n\n      case 'parentFk':\n        if (!this.hasParentAttributes()) {\n          return;\n        }\n\n        if (this.isThrough()) {\n          if (this.type === 'belongsToMany' && this.isThroughForeignKeyTargeted()) {\n            return this.parentAttributes[this.throughForeignKeyTarget];\n          }\n\n          if (this.type === 'belongsTo') {\n            return this.throughForeignKey ? this.parentAttributes[this.parentIdAttribute] : this.parentId;\n          }\n\n          if (this.isOtherKeyTargeted()) {\n            return this.parentAttributes[this.otherKeyTarget];\n          }\n\n          // Return attribute calculated on `init` by default.\n          return this.parentFk;\n        }\n\n        return this.parentAttributes[this.isInverse() ? this.key('foreignKey') : this.parentIdAttribute];\n    }\n  },\n\n\n  // Injects the necessary `select` constraints into a `knex` query builder.\n  selectConstraints: function selectConstraints(knex, options) {\n    var resp = options.parentResponse;\n\n    // The `belongsToMany` and `through` relations have joins & pivot columns.\n    if (this.isJoined()) this.joinClauses(knex);\n\n    // Call the function, if one exists, to constrain the eager loaded query.\n    if (options._beforeFn) options._beforeFn.call(knex, knex);\n\n    // The base select column\n    if (_lodash2.default.isArray(options.columns)) {\n      knex.columns(options.columns);\n    }\n\n    var currentColumns = _lodash2.default.find(knex._statements, { grouping: 'columns' });\n\n    if (!currentColumns || currentColumns.length === 0) {\n      knex.column(this.targetTableName + '.*');\n    }\n\n    if (this.isJoined()) this.joinColumns(knex);\n\n    // If this is a single relation and we're not eager loading,\n    // limit the query to a single item.\n    if (this.isSingle() && !resp) knex.limit(1);\n\n    // Finally, add (and validate) the where conditions, necessary for constraining the relation.\n    this.whereClauses(knex, resp);\n  },\n\n  // Inject & validates necessary `through` constraints for the current model.\n  joinColumns: function joinColumns(knex) {\n    var columns = [];\n    var joinTable = this.joinTable();\n    if (this.isThrough()) columns.push(this.throughIdAttribute);\n    columns.push(this.key('foreignKey'));\n    if (this.type === 'belongsToMany') columns.push(this.key('otherKey'));\n    push.apply(columns, this.pivotColumns);\n    knex.columns(_lodash2.default.map(columns, function (col) {\n      return joinTable + '.' + col + ' as _pivot_' + col;\n    }));\n  },\n\n  // Generates the join clauses necessary for the current relation.\n  joinClauses: function joinClauses(knex) {\n    var joinTable = this.joinTable();\n\n    if (this.type === 'belongsTo' || this.type === 'belongsToMany') {\n\n      var targetKey = this.type === 'belongsTo' ? this.key('foreignKey') : this.key('otherKey');\n\n      knex.join(joinTable, joinTable + '.' + targetKey, '=', this.targetTableName + '.' + this.targetIdAttribute);\n\n      // A `belongsTo` -> `through` is currently the only relation with two joins.\n      if (this.type === 'belongsTo') {\n        knex.join(this.parentTableName, joinTable + '.' + this.throughIdAttribute, '=', this.parentTableName + '.' + this.key('throughForeignKey'));\n      }\n    } else {\n      knex.join(joinTable, joinTable + '.' + this.throughIdAttribute, '=', this.targetTableName + '.' + this.key('throughForeignKey'));\n    }\n  },\n\n  // Check that there isn't an incorrect foreign key set, vs. the one\n  // passed in when the relation was formed.\n  whereClauses: function whereClauses(knex, response) {\n    var key = void 0;\n\n    if (this.isJoined()) {\n      var isBelongsTo = this.type === 'belongsTo';\n      var targetTable = isBelongsTo ? this.parentTableName : this.joinTable();\n\n      var column = isBelongsTo ? this.parentIdAttribute : this.key('foreignKey');\n\n      key = targetTable + '.' + column;\n    } else {\n      var _column = this.isInverse() ? this.targetIdAttribute : this.key('foreignKey');\n\n      key = this.targetTableName + '.' + _column;\n    }\n\n    var method = response ? 'whereIn' : 'where';\n    var ids = response ? this.eagerKeys(response) : this.parentFk;\n    knex[method](key, ids);\n\n    if (this.isMorph()) {\n      var table = this.targetTableName;\n      var _key = this.key('morphKey');\n      var value = this.key('morphValue');\n      knex.where(table + '.' + _key, value);\n    }\n  },\n\n  // Fetches all `eagerKeys` from the current relation.\n  eagerKeys: function eagerKeys(response) {\n    var key = this.isInverse() && !this.isThrough() ? this.key('foreignKey') : this.parentIdAttribute;\n    return (0, _lodash2.default)(response).map(key).uniq().value();\n  },\n\n  // Generates the appropriate standard join table.\n  joinTable: function joinTable() {\n    if (this.isThrough()) return this.throughTableName;\n    return this.joinTableName || [this.parentTableName, this.targetTableName].sort().join('_');\n  },\n\n  // Creates a new model or collection instance, depending on\n  // the `relatedData` settings and the models passed in.\n  relatedInstance: function relatedInstance(models) {\n    models = models || [];\n\n    var Target = this.target;\n\n    // If it's a single model, check whether there's already a model\n    // we can pick from... otherwise create a new instance.\n    if (this.isSingle()) {\n      if (!(Target.prototype instanceof _model2.default)) {\n        throw new Error('The ' + this.type + ' related object must be a Bookshelf.Model');\n      }\n      return models[0] || new Target();\n    }\n\n    // Allows us to just use a model, but create a temporary\n    // collection for a \"*-many\" relation.\n    if (Target.prototype instanceof _model2.default) {\n      return Target.collection(models, { parse: true });\n    }\n    return new Target(models, { parse: true });\n  },\n\n  // Groups the related response according to the type of relationship\n  // we're handling, for easy attachment to the parent models.\n  eagerPair: function eagerPair(relationName, related, parentModels) {\n    var _this = this;\n\n    // If this is a morphTo, we only want to pair on the morphValue for the current relation.\n    if (this.type === 'morphTo') {\n      parentModels = _lodash2.default.filter(parentModels, function (m) {\n        return m.get(_this.key('morphKey')) === _this.key('morphValue');\n      });\n    }\n\n    // If this is a `through` or `belongsToMany` relation, we need to cleanup & setup the `interim` model.\n    if (this.isJoined()) related = this.parsePivot(related);\n\n    // Group all of the related models for easier association with their parent models.\n    var grouped = _lodash2.default.groupBy(related, function (m) {\n      if (m.pivot) {\n        if (_this.isInverse() && _this.isThrough()) {\n          return _this.isThroughForeignKeyTargeted() ? m.pivot.get(_this.throughForeignKeyTarget) : m.pivot.id;\n        }\n\n        return m.pivot.get(_this.key('foreignKey'));\n      }\n\n      if (_this.isInverse()) {\n        return _this.isForeignKeyTargeted() ? m.get(_this.foreignKeyTarget) : m.id;\n      }\n\n      return m.get(_this.key('foreignKey'));\n    });\n\n    // Loop over the `parentModels` and attach the grouped sub-models,\n    // keeping the `relatedData` on the new related instance.\n    _lodash2.default.each(parentModels, function (model) {\n      var groupedKey = void 0;\n      if (!_this.isInverse()) {\n        groupedKey = model.get(_this.parentIdAttribute);\n      } else {\n        var keyColumn = _this.key(_this.isThrough() ? 'throughForeignKey' : 'foreignKey');\n        var formatted = model.format(_lodash2.default.clone(model.attributes));\n        groupedKey = formatted[keyColumn];\n      }\n      var relation = model.relations[relationName] = _this.relatedInstance(grouped[groupedKey]);\n      relation.relatedData = _this;\n      if (_this.isJoined()) _lodash2.default.extend(relation, pivotHelpers);\n    });\n\n    // Now that related models have been successfully paired, update each with\n    // its parsed attributes\n    related.map(function (model) {\n      model.attributes = model.parse(model.attributes);\n    });\n\n    return related;\n  },\n\n\n  parsePivot: function parsePivot(models) {\n    var _this2 = this;\n\n    return _lodash2.default.map(models, function (model) {\n\n      // Separate pivot attributes.\n      var grouped = _lodash2.default.reduce(model.attributes, function (acc, value, key) {\n        if (hasPivotPrefix(key)) {\n          acc.pivot[removePivotPrefix(key)] = value;\n        } else {\n          acc.model[key] = value;\n        }\n        return acc;\n      }, { model: {}, pivot: {} });\n\n      // Assign non-pivot attributes to model.\n      model.attributes = grouped.model;\n\n      // If there are any pivot attributes, create a new pivot model with these\n      // attributes.\n      if (!_lodash2.default.isEmpty(grouped.pivot)) {\n        var Through = _this2.throughTarget;\n        var tableName = _this2.joinTable();\n        model.pivot = Through != null ? new Through(grouped.pivot) : new _this2.Model(grouped.pivot, { tableName: tableName });\n      }\n\n      return model;\n    });\n  },\n\n  // A few predicates to help clarify some of the logic above.\n  isThrough: function isThrough() {\n    return this.throughTarget != null;\n  },\n  isJoined: function isJoined() {\n    return this.type === 'belongsToMany' || this.isThrough();\n  },\n  isMorph: function isMorph() {\n    return this.type === 'morphOne' || this.type === 'morphMany';\n  },\n  isSingle: function isSingle() {\n    var type = this.type;\n    return type === 'hasOne' || type === 'belongsTo' || type === 'morphOne' || type === 'morphTo';\n  },\n  isInverse: function isInverse() {\n    return this.type === 'belongsTo' || this.type === 'morphTo';\n  },\n  isForeignKeyTargeted: function isForeignKeyTargeted() {\n    return this.foreignKeyTarget != null;\n  },\n  isThroughForeignKeyTargeted: function isThroughForeignKeyTargeted() {\n    return this.throughForeignKeyTarget != null;\n  },\n  isOtherKeyTargeted: function isOtherKeyTargeted() {\n    return this.otherKeyTarget != null;\n  },\n  hasParentAttributes: function hasParentAttributes() {\n    return this.parentAttributes != null;\n  },\n\n\n  // Sets the `pivotColumns` to be retrieved along with the current model.\n  withPivot: function withPivot(columns) {\n    if (!_lodash2.default.isArray(columns)) columns = [columns];\n    this.pivotColumns = this.pivotColumns || [];\n    push.apply(this.pivotColumns, columns);\n  }\n\n});\n\n// Simple memoization of the singularize call.\n\nvar singularMemo = function () {\n  var cache = Object.create(null);\n  return function (arg) {\n    if (!(arg in cache)) {\n      cache[arg] = _inflection2.default.singularize(arg);\n    }\n    return cache[arg];\n  };\n}();\n\n// Specific to many-to-many relationships, these methods are mixed\n// into the `belongsToMany` relationships when they are created,\n// providing helpers for attaching and detaching related models.\nvar pivotHelpers = {\n\n  /**\n   * Attaches one or more `ids` or models from a foreign table to the current\n   * table, on a {@linkplain many-to-many} relation. Creates and saves a new\n   * model and attaches the model with the related model.\n   *\n   *     var admin1 = new Admin({username: 'user1', password: 'test'});\n   *     var admin2 = new Admin({username: 'user2', password: 'test'});\n   *\n   *     Promise.all([admin1.save(), admin2.save()])\n   *       .then(function() {\n   *         return Promise.all([\n   *         new Site({id: 1}).admins().attach([admin1, admin2]),\n   *         new Site({id: 2}).admins().attach(admin2)\n   *       ]);\n   *     })\n   *\n   * This method (along with {@link Collection#detach} and {@link\n   * Collection#updatePivot}) are mixed in to a {@link Collection} when\n   * returned by a {@link Model#belongsToMany belongsToMany} relation.\n   *\n   * @method Collection#attach\n   * @param {mixed|mixed[]} ids\n   *   One or more ID values or models to be attached to the relation.\n   * @param {Object} options\n   *   A hash of options.\n   * @param {Transaction} options.transacting\n   *   Optionally run the query in a transaction.\n   * @returns {Promise<Collection>}\n   *   A promise resolving to the updated Collection.\n   */\n  attach: function attach(ids, options) {\n    var _this3 = this;\n\n    return _promise2.default.try(function () {\n      return _this3.triggerThen('attaching', _this3, ids, options);\n    }).then(function () {\n      return _this3._handler('insert', ids, options);\n    }).then(function (response) {\n      return _this3.triggerThen('attached', _this3, response, options);\n    }).return(this);\n  },\n\n\n  /**\n   * Detach one or more related objects from their pivot tables. If a model or\n   * id is passed, it attempts to remove the pivot table based on that foreign\n   * key. If no parameters are specified, we assume we will detach all related\n   * associations.\n   *\n   * This method (along with {@link Collection#attach} and {@link\n   * Collection#updatePivot}) are mixed in to a {@link Collection} when returned\n   * by a {@link Model#belongsToMany belongsToMany} relation.\n   *\n   * @method Collection#detach\n   * @param {mixed|mixed[]} [ids]\n   *   One or more ID values or models to be detached from the relation.\n   * @param {Object} options\n   *   A hash of options.\n   * @param {Transaction} options.transacting\n   *   Optionally run the query in a transaction.\n   * @returns {Promise<undefined>}\n   *   A promise resolving to `undefined`.\n   */\n  detach: function detach(ids, options) {\n    var _this4 = this;\n\n    return _promise2.default.try(function () {\n      return _this4.triggerThen('detaching', _this4, ids, options);\n    }).then(function () {\n      return _this4._handler('delete', ids, options);\n    }).then(function (response) {\n      return _this4.triggerThen('detached', _this4, response, options);\n    }).return(this);\n  },\n\n\n  /**\n   * The `updatePivot` method is used exclusively on {@link Model#belongsToMany\n   * belongsToMany} relations, and allows for updating pivot rows on the joining\n   * table.\n   *\n   * This method (along with {@link Collection#attach} and {@link\n   * Collection#detach}) are mixed in to a {@link Collection} when returned\n   * by a {@link Model#belongsToMany belongsToMany} relation.\n   *\n   * @method Collection#updatePivot\n   * @param {Object} attributes\n   *   Values to be set in the `update` query.\n   * @param {Object} [options]\n   *   A hash of options.\n   * @param {function|Object} [options.query]\n   *   Constrain the update query. Similar to the `method` argument to {@link\n   *   Model#query}.\n   * @param {bool} [options.require=false]\n   *   Causes promise to be rejected with an Error if no rows were updated.\n   * @param {Transaction} [options.transacting]\n   *   Optionally run the query in a transaction.\n   * @returns {Promise<Number>}\n   *   A promise resolving to number of rows updated.\n   */\n  updatePivot: function updatePivot(attributes, options) {\n    return this._handler('update', attributes, options);\n  },\n\n  /**\n   * The `withPivot` method is used exclusively on {@link Model#belongsToMany\n   * belongsToMany} relations, and allows for additional fields to be pulled\n   * from the joining table.\n   *\n   *     var Tag = bookshelf.Model.extend({\n   *       comments: function() {\n   *         return this.belongsToMany(Comment).withPivot(['created_at', 'order']);\n   *       }\n   *     });\n   *\n   * @method Collection#withPivot\n   * @param {string[]} columns\n   *   Names of columns to be included when retrieving pivot table rows.\n   * @returns {Collection}\n   *   Self, this method is chainable.\n   */\n  withPivot: function withPivot(columns) {\n    this.relatedData.withPivot(columns);\n    return this;\n  },\n\n  // Helper for handling either the `attach` or `detach` call on\n  // the `belongsToMany` or `hasOne` / `hasMany` :through relationship.\n  _handler: _promise2.default.method(function (method, ids, options) {\n    var _this5 = this;\n\n    var pending = [];\n    if (ids == null) {\n      if (method === 'insert') return _promise2.default.resolve(this);\n      if (method === 'delete') pending.push(this._processPivot(method, null, options));\n    }\n    if (!_lodash2.default.isArray(ids)) ids = ids ? [ids] : [];\n    _lodash2.default.each(ids, function (id) {\n      return pending.push(_this5._processPivot(method, id, options));\n    });\n    return _promise2.default.all(pending).return(this);\n  }),\n\n  // Handles preparing the appropriate constraints and then delegates\n  // the database interaction to _processPlainPivot for non-.through()\n  // pivot definitions, or _processModelPivot for .through() models.\n  // Returns a promise.\n  _processPivot: _promise2.default.method(function (method, item) {\n    var relatedData = this.relatedData,\n        args = Array.prototype.slice.call(arguments),\n        fks = {},\n        data = {};\n\n    fks[relatedData.key('foreignKey')] = relatedData.parentFk;\n\n    // If the item is an object, it's either a model\n    // that we're looking to attach to this model, or\n    // a hash of attributes to set in the relation.\n    if (_lodash2.default.isObject(item)) {\n      if (item instanceof _model2.default) {\n        fks[relatedData.key('otherKey')] = item.id;\n      } else if (method !== 'update') {\n        _lodash2.default.extend(data, item);\n      }\n    } else if (item) {\n      fks[relatedData.key('otherKey')] = item;\n    }\n\n    args.push(_lodash2.default.extend(data, fks), fks);\n\n    if (this.relatedData.throughTarget) {\n      return this._processModelPivot.apply(this, args);\n    }\n\n    return this._processPlainPivot.apply(this, args);\n  }),\n\n  // Applies constraints to the knex builder and handles shelling out\n  // to either the `insert` or `delete` call for the current model,\n  // returning a promise.\n  _processPlainPivot: _promise2.default.method(function (method, item, options, data) {\n    var relatedData = this.relatedData;\n\n    // Grab the `knex` query builder for the current model, and\n    // check if we have any additional constraints for the query.\n    var builder = this._builder(relatedData.joinTable());\n    if (options && options.query) {\n      _helpers2.default.query.call(null, { _knex: builder }, [options.query]);\n    }\n\n    if (options) {\n      if (options.transacting) builder.transacting(options.transacting);\n      if (options.debug) builder.debug();\n    }\n\n    var collection = this;\n    if (method === 'delete') {\n      return builder.where(data).del().then(function () {\n        if (!item) return collection.reset();\n        var model = collection.get(data[relatedData.key('otherKey')]);\n        if (model) {\n          collection.remove(model);\n        }\n      });\n    }\n    if (method === 'update') {\n      return builder.where(data).update(item).then(function (numUpdated) {\n        if (options && options.require === true && numUpdated === 0) {\n          throw new Error('No rows were updated');\n        }\n        return numUpdated;\n      });\n    }\n\n    return this.triggerThen('creating', this, data, options).then(function () {\n      return builder.insert(data).then(function () {\n        collection.add(item);\n      });\n    });\n  }),\n\n  // Loads or prepares a pivot model based on the constraints and deals with\n  // pivot model changes by calling the appropriate Bookshelf Model API\n  // methods. Returns a promise.\n  _processModelPivot: _promise2.default.method(function (method, item, options, data, fks) {\n    var relatedData = this.relatedData,\n        JoinModel = relatedData.throughTarget,\n        joinModel = new JoinModel();\n\n    fks = joinModel.parse(fks);\n    data = joinModel.parse(data);\n\n    if (method === 'insert') {\n      return joinModel.set(data).save(null, options);\n    }\n\n    return joinModel.set(fks).fetch({\n      require: true\n    }).then(function (instance) {\n      if (method === 'delete') {\n        return instance.destroy(options);\n      }\n      return instance.save(item, options);\n    });\n  })\n\n};","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/base/relation.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _lodash = require('lodash');\n\nvar _collection = require('./collection');\n\nvar _collection2 = _interopRequireDefault(_collection);\n\nvar _extend = require('../extend');\n\nvar _extend2 = _interopRequireDefault(_extend);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// Used internally, the `Relation` helps in simplifying the relationship building,\n// centralizing all logic dealing with type & option handling.\nvar RelationBase = function () {\n  function RelationBase(type, Target, options) {\n    (0, _classCallCheck3.default)(this, RelationBase);\n\n    if (Target != null) {\n      this.targetTableName = (0, _lodash.result)(Target.prototype, 'tableName');\n      this.targetIdAttribute = (0, _lodash.result)(Target.prototype, 'idAttribute');\n    }\n    (0, _lodash.assign)(this, { type: type, target: Target }, options);\n  }\n\n  // Creates a new relation instance, used by the `Eager` relation in\n  // dealing with `morphTo` cases, where the same relation is targeting multiple models.\n\n\n  (0, _createClass3.default)(RelationBase, [{\n    key: 'instance',\n    value: function instance(type, Target, options) {\n      return new this.constructor(type, Target, options);\n    }\n\n    // Creates a new, unparsed model, used internally in the eager fetch helper\n    // methods. (Parsing may mutate information necessary for eager pairing.)\n\n  }, {\n    key: 'createModel',\n    value: function createModel(data) {\n      if (this.target.prototype instanceof _collection2.default) {\n        return new this.target.prototype.model(data)._reset();\n      }\n      return new this.target(data)._reset();\n    }\n\n    // Eager pair the models.\n\n  }, {\n    key: 'eagerPair',\n    value: function eagerPair() {}\n  }]);\n  return RelationBase;\n}(); // Base Relation\n// ---------------\n\nexports.default = RelationBase;\n\n\n(0, _lodash.assign)(RelationBase, { extend: _extend2.default });","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/lib/constants.js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar PIVOT_PREFIX = exports.PIVOT_PREFIX = '_pivot_';","/home/travis/build/npmtest/node-npmtest-bookshelf/node_modules/bookshelf/scripts/promise.js":"var Promise = require('bluebird')\nvar helpers = require('../helpers')\n\nPromise.prototype.yield = function() {\n  helpers.deprecate('.yield', '.return')\n  return this.return.apply(this, arguments);\n}\nPromise.prototype.ensure = function() {\n  helpers.deprecate('.ensure', '.finally')\n  return this.finally.apply(this, arguments);\n}\nPromise.prototype.otherwise = function() {\n  helpers.deprecate('.otherwise', '.catch')\n  return this.catch.apply(this, arguments);\n}\nPromise.prototype.exec = function() {\n  helpers.deprecate('bookshelf.exec', 'bookshelf.asCallback')\n  return this.nodeify.apply(this, arguments);\n};\n\nmodule.exports = Promise"}